<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DD Owl</title>
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .main-content {
      flex: 1;
      padding: 20px;
      padding-bottom: 320px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
    }

    .header-logo {
      width: 150px;
      height: auto;
      display: block;
    }

    .logo {
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 2px;
      margin: -26px 0 4px 0;
      line-height: 1;
    }

    .subtitle {
      color: #666;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .search-box {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 24px;
      margin-bottom: 24px;
    }

    .queue-panel {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      margin-bottom: 24px;
      overflow: hidden;
    }

    .queue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #0d0d0d;
      border-bottom: 1px solid #222;
    }

    .queue-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #888;
    }

    .queue-toggle {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 12px;
    }

    .queue-body {
      padding: 12px 16px;
    }

    .queue-list {
      margin-bottom: 12px;
    }

    .queue-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #0a0a0a;
      border: 1px solid #1a1a1a;
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .queue-item.running {
      border-left: 3px solid #4a9eff;
    }

    .queue-item.complete {
      border-left: 3px solid #2ed573;
    }

    .queue-item.error {
      border-left: 3px solid #ff4757;
    }

    .queue-item-name {
      font-weight: 500;
      color: #fff;
    }

    .queue-item-status {
      font-size: 11px;
      text-transform: uppercase;
      color: #666;
    }

    .queue-item-status.running { color: #4a9eff; }
    .queue-item-status.complete { color: #2ed573; }
    .queue-item-status.error { color: #ff4757; }

    .queue-item.complete.clickable {
      cursor: pointer;
    }

    .queue-item.complete.clickable:hover {
      background: #151515;
    }

    .queue-item-main {
      flex: 1;
      min-width: 0;
    }

    .queue-item-stats {
      font-size: 11px;
      color: #888;
      margin-left: 8px;
    }

    .queue-item-stats .red-count {
      color: #ff4757;
      font-weight: 600;
    }

    .queue-item-stats .amber-count {
      color: #ffa502;
      font-weight: 600;
    }

    .queue-item-actions {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-left: 12px;
    }

    .queue-item-actions button {
      padding: 4px 8px;
      font-size: 10px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
    }

    .queue-item-actions .btn-view {
      background: #1a3a5c;
      color: #4a9eff;
    }

    .queue-item-actions .btn-view:hover {
      background: #234b73;
    }

    .queue-item-actions .btn-remove {
      background: transparent;
      color: #666;
      padding: 4px 6px;
    }

    .queue-item-actions .btn-remove:hover {
      color: #ff4757;
    }

    .queue-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .btn-sm {
      padding: 8px 14px;
      font-size: 11px;
    }

    .input-group {
      display: flex;
      gap: 12px;
    }

    input[type="text"] {
      flex: 1;
      padding: 14px 18px;
      font-size: 16px;
      font-family: inherit;
      border: 1px solid #333;
      border-radius: 6px;
      background: #0a0a0a;
      color: #fff;
      outline: none;
      transition: border-color 0.2s;
    }

    input[type="text"]:focus {
      border-color: #4a9eff;
    }

    input[type="text"]::placeholder {
      color: #444;
    }

    button {
      padding: 14px 28px;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn-primary {
      background: #fff;
      color: #000;
    }

    .btn-primary:hover {
      background: #e0e0e0;
    }

    .btn-primary:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 24px;
    }

    .stat-card {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
    }

    .stat-card.red { border-left: 3px solid #ff4757; }
    .stat-card.amber { border-left: 3px solid #ffa502; }
    .stat-card.green { border-left: 3px solid #2ed573; }

    .stat-number {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .stat-card.red .stat-number { color: #ff4757; }
    .stat-card.red .stat-label { color: #ff4757; }
    .stat-card.amber .stat-number { color: #ffa502; }
    .stat-card.amber .stat-label { color: #ffa502; }

    .stat-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .results-section {
      display: none;
    }

    .results-section.active {
      display: block;
    }

    .flags-list {
      margin-bottom: 20px;
    }

    .flags-header {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 2px;
      padding-bottom: 8px;
      border-bottom: 1px solid #222;
    }

    .flags-header.red { color: #ff4757; }
    .flags-header.amber { color: #ffa502; }

    .flag-item {
      background: #111;
      border: 1px solid #222;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 10px;
      border-left: 3px solid;
    }

    .flag-item.red { border-left-color: #ff4757; }
    .flag-item.amber { border-left-color: #ffa502; }

    .flag-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: #fff;
      font-size: 14px;
    }

    .flag-title a {
      color: inherit;
      text-decoration: none;
    }

    .flag-title a:hover {
      text-decoration: underline;
    }

    .flag-summary {
      font-size: 13px;
      color: #888;
      line-height: 1.6;
      margin-bottom: 10px;
    }

    .flag-meta {
      font-size: 11px;
      color: #555;
      display: flex;
      gap: 12px;
    }

    .flag-category {
      background: #1a1a1a;
      padding: 3px 8px;
      border-radius: 4px;
      border: 1px solid #333;
    }

    .flag-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 8px;
    }

    .flag-date {
      font-size: 11px;
      color: #666;
      background: #1a1a1a;
      padding: 3px 8px;
      border-radius: 4px;
      white-space: nowrap;
    }

    .flag-sources {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #222;
    }

    .source-badge {
      display: inline-block;
      background: #2a2a2a;
      color: #4a9eff;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .sources-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .sources-list a {
      font-size: 11px;
      color: #555;
      text-decoration: none;
    }

    .sources-list a:hover {
      color: #4a9eff;
    }

    .action-box {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 20px;
      margin-top: 24px;
    }

    .action-title {
      font-size: 10px;
      color: #666;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .action-text {
      font-size: 14px;
      font-weight: 600;
    }

    .action-text.escalate { color: #ff4757; }
    .action-text.review { color: #ffa502; }

    /* Navigation */
    .top-nav {
      background: #111;
      border-bottom: 1px solid #222;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 32px;
    }
    .nav-brand {
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      text-decoration: none;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .nav-logo {
      height: 28px;
      width: auto;
    }
    .nav-links {
      display: flex;
      gap: 8px;
    }
    .nav-link {
      padding: 8px 16px;
      color: #888;
      text-decoration: none;
      font-size: 13px;
      border-radius: 6px;
      transition: all 0.2s;
    }
    .nav-link:hover {
      color: #fff;
      background: #1a1a1a;
    }
    .nav-link.active {
      color: #fff;
      background: #222;
    }
    .action-text.clear { color: #2ed573; }

    .download-btn {
      margin-top: 20px;
      background: #1a1a1a;
      color: #888;
      width: 100%;
      border: 1px solid #333;
    }

    .download-btn:hover {
      background: #222;
      color: #fff;
    }

    /* Activity Log Panel */
    .activity-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70vh; /* 70% of viewport - shows up to owl's head */
      background: #0d0d0d;
      border-top: 1px solid #222;
      display: flex;
      flex-direction: column;
      font-size: 12px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }

    .activity-panel.active {
      transform: translateY(0);
    }

    .activity-resize-handle {
      height: 8px;
      background: linear-gradient(to bottom, #333 0%, #1a1a1a 100%);
      cursor: ns-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      border-bottom: 1px solid #222;
    }

    .activity-resize-handle:hover {
      background: linear-gradient(to bottom, #444 0%, #222 100%);
    }

    .activity-resize-handle::before {
      content: '';
      width: 40px;
      height: 4px;
      background: #555;
      border-radius: 2px;
    }

    .activity-resize-handle:hover::before {
      background: #777;
    }

    .activity-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background: #111;
      border-bottom: 1px solid #222;
    }

    .activity-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: #666;
    }

    .copy-log-btn {
      background: transparent;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 4px 6px;
      cursor: pointer;
      color: #666;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .copy-log-btn:hover {
      background: #222;
      color: #7cc576;
      border-color: #7cc576;
    }
    .copy-log-btn.copied {
      color: #7cc576;
      border-color: #7cc576;
    }

    .activity-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #333;
    }

    .status-dot.active {
      background: #2ed573;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .activity-stats {
      font-size: 11px;
      color: #555;
    }

    .activity-panel {
      overflow: hidden;
    }

    .activity-log {
      flex: 1;
      overflow-y: scroll;
      overflow-x: hidden;
      padding: 0;
      font-family: 'SF Mono', 'Menlo', monospace;
      width: 100%;
      max-width: 100%;
    }

    .activity-log::-webkit-scrollbar {
      width: 8px;
    }

    .activity-log::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    .activity-log::-webkit-scrollbar-thumb {
      background: #666;
      border-radius: 4px;
    }

    .activity-log::-webkit-scrollbar-thumb:hover {
      background: #888;
    }

    .log-entry {
      display: flex;
      padding: 8px 20px 8px 20px;
      padding-right: 28px;
      border-bottom: 1px solid #1a1a1a;
      gap: 16px;
      max-width: 100%;
      overflow: hidden;
    }

    .log-entry:hover {
      background: #111;
    }

    .log-time {
      color: #444;
      min-width: 70px;
    }

    .log-type {
      min-width: 80px;
      font-weight: 600;
    }

    .log-type.search { color: #4a9eff; }
    .log-type.fetch { color: #a855f7; }
    .log-type.analyze { color: #f59e0b; }
    .log-type.result { color: #2ed573; }
    .log-type.red { color: #ff4757; }
    .log-type.amber { color: #ffa502; }
    .log-type.green { color: #2ed573; }
    .log-type.error { color: #ff4757; }

    .log-message {
      color: #888;
      flex: 1;
      min-width: 0;
      word-break: break-word;
    }

    .log-message a {
      color: #4a9eff;
      text-decoration: none;
    }

    .log-message a:hover {
      text-decoration: underline;
    }

    .bottom-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .toggle-panel {
      padding: 10px 16px;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #888;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      border-radius: 6px;
    }

    .toggle-panel:hover {
      background: #222;
      color: #fff;
    }

    .toggle-panel.hidden {
      display: none;
    }

    .disconnect-btn {
      padding: 10px 16px;
      background: #2a1a1a;
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      border-radius: 6px;
    }
    .disconnect-btn:hover {
      background: #3a2020;
    }

    .resume-btn {
      padding: 10px 16px;
      background: #1a2a1a;
      border: 1px solid #7cc576;
      color: #7cc576;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      border-radius: 6px;
    }
    .resume-btn:hover {
      background: #2a3a2a;
    }

    /* Report Modal */
    .report-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      overflow: hidden;
    }

    .report-modal.active {
      display: flex;
      flex-direction: column;
    }

    .report-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: #111;
      border-bottom: 1px solid #222;
    }

    .report-modal-title {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    .report-modal-status {
      font-size: 12px;
      color: #666;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .report-modal-status .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #2ed573;
      animation: pulse 1s infinite;
    }

    .report-modal-status.complete .status-dot {
      animation: none;
      background: #2ed573;
    }

    .report-modal-close {
      background: none;
      border: 1px solid #333;
      color: #888;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
    }

    .report-modal-close:hover {
      background: #222;
      color: #fff;
    }

    .report-modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      background: #0a0a0a;
    }

    .report-content {
      max-width: 800px;
      margin: 0 auto;
      font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
      font-size: 13px;
      line-height: 1.7;
      color: #d0d0d0;
      white-space: pre-wrap;
    }

    .report-content h1 {
      font-size: 24px;
      margin-bottom: 16px;
      color: #fff;
      font-family: inherit;
    }

    .report-content h2 {
      font-size: 18px;
      margin: 24px 0 12px 0;
      color: #fff;
      font-family: inherit;
      border-bottom: 1px solid #333;
      padding-bottom: 8px;
    }

    .report-content strong {
      color: #fff;
    }

    .report-content em {
      color: #888;
    }

    .report-content a {
      color: #4a9eff;
    }

    .report-cursor {
      display: inline-block;
      width: 2px;
      height: 1em;
      background: #4a9eff;
      animation: blink 0.8s infinite;
      vertical-align: text-bottom;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .report-modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 16px 24px;
      background: #111;
      border-top: 1px solid #222;
    }

    .report-modal-footer button {
      padding: 10px 20px;
      font-size: 12px;
    }

    .btn-secondary {
      background: #222;
      color: #888;
      border: 1px solid #333;
    }

    .btn-secondary:hover {
      background: #333;
      color: #fff;
    }

    .btn-secondary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-generate {
      background: #1a472a;
      color: #2ed573;
      border: 1px solid #2ed573;
      margin-left: 12px;
    }

    .btn-generate:hover {
      background: #2ed573;
      color: #000;
    }

    .btn-generate:disabled {
      background: #1a1a1a;
      color: #444;
      border-color: #333;
      cursor: not-allowed;
    }

    /* Language Selector */
    .language-selector {
      position: relative;
    }

    .language-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    .language-btn:hover {
      border-color: #444;
    }

    .lang-arrow {
      font-size: 10px;
      color: #666;
      transition: transform 0.2s;
    }

    .language-selector.open .lang-arrow {
      transform: rotate(180deg);
    }

    .language-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      width: 200px;
      max-height: 300px;
      overflow: hidden;
      z-index: 100;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .language-selector.open .language-dropdown {
      display: block;
    }

    .lang-search {
      width: 100%;
      padding: 12px;
      border: none;
      border-bottom: 1px solid #222;
      background: transparent;
      color: #fff;
      font-size: 14px;
      font-family: inherit;
      outline: none;
      box-sizing: border-box;
    }

    .lang-search::placeholder {
      color: #555;
    }

    .lang-list {
      max-height: 240px;
      overflow-y: auto;
    }

    .lang-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      cursor: pointer;
      transition: background 0.15s;
    }

    .lang-option:hover:not(.disabled) {
      background: #1a1a1a;
    }

    .lang-option.selected {
      background: #1a1a1a;
    }

    .lang-option.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .lang-label {
      flex: 1;
      font-size: 14px;
    }

    .lang-badge {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
    }

    .lang-check {
      color: #4a9eff;
    }

    /* Further Links Button & Modal */
    .btn-further-links {
      padding: 12px 20px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 6px;
      color: #888;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-further-links:hover {
      background: #222;
      color: #fff;
      border-color: #444;
    }

    .further-links-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .further-links-content {
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      width: 90%;
      max-width: 700px;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
    }

    .further-links-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid #222;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    .further-links-list {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .further-link-item {
      padding: 12px 16px;
      border-bottom: 1px solid #1a1a1a;
    }

    .further-link-item:last-child {
      border-bottom: none;
    }

    .further-link-title {
      color: #4a9eff;
      text-decoration: none;
      font-size: 13px;
      display: block;
      margin-bottom: 4px;
    }

    .further-link-title:hover {
      text-decoration: underline;
    }

    .further-link-url {
      color: #555;
      font-size: 11px;
      word-break: break-all;
    }

    .further-link-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .further-link-category {
      font-size: 10px;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: uppercase;
    }

    .further-link-category.red {
      background: rgba(255, 71, 87, 0.2);
      color: #ff4757;
    }

    .further-link-category.amber {
      background: rgba(255, 165, 2, 0.2);
      color: #ffa502;
    }

    .further-link-reason {
      color: #888;
      font-size: 11px;
      margin-bottom: 4px;
      font-style: italic;
    }

    .further-link-triage {
      color: #666;
      font-size: 11px;
      margin-bottom: 4px;
      padding: 4px 8px;
      background: #1a1a1a;
      border-radius: 4px;
    }

    /* Finding checkboxes */
    .finding-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #4a9eff;
      flex-shrink: 0;
    }

    .flag-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .flag-content {
      flex: 1;
      min-width: 0;
    }

    .flag-item.selected {
      background: #1a1a2a;
      border-color: #4a9eff;
    }

    /* Detail Report Modal */
    .detail-report-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      overflow: hidden;
    }

    .detail-report-modal.active {
      display: flex;
      flex-direction: column;
    }

    .detail-finding {
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .detail-finding-header {
      font-size: 16px;
      font-weight: 600;
      color: #fff;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #333;
    }

    .detail-finding-section {
      margin-bottom: 16px;
    }

    .detail-finding-section h4 {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #666;
      margin-bottom: 8px;
    }

    .detail-finding-section p {
      color: #ccc;
      line-height: 1.6;
    }

    /* Progress Card - handles running, paused, complete states */
    .progress-card {
      background: #111;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 24px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .progress-card.running { border-color: #4a9eff; }
    .progress-card.paused { border-color: #f5a623; }
    .progress-card.complete { border-color: #2ed573; }
    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .progress-title {
      font-size: 16px;
      color: #e0e0e0;
    }
    .progress-title .status-icon { margin-right: 8px; }
    .progress-percentage {
      font-size: 24px;
      font-weight: bold;
      color: #4a9eff;
    }
    .progress-card.paused .progress-percentage { color: #f5a623; }
    .progress-card.complete .progress-percentage { color: #2ed573; }
    .progress-bar-container {
      background: #222;
      border-radius: 4px;
      height: 8px;
      margin: 12px 0;
      overflow: hidden;
    }
    .progress-bar-fill {
      background: linear-gradient(90deg, #4a9eff, #2ed573);
      height: 100%;
      width: 0%;
      transition: width 0.3s ease;
    }
    .progress-card.paused .progress-bar-fill { background: #f5a623; }
    .progress-card.complete .progress-bar-fill { background: #2ed573; }
    .progress-stats {
      color: #888;
      font-size: 14px;
      margin-bottom: 16px;
    }
    .progress-actions {
      display: flex;
      gap: 12px;
    }
    .btn-pause {
      background: #333;
      color: #e0e0e0;
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
    }
    .btn-pause:hover { background: #444; }
    .btn-resume {
      background: #f5a623;
      color: black;
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
    }
    .btn-resume:hover { background: #ffc04d; }
    .btn-cancel, .btn-discard {
      background: transparent;
      color: #888;
      padding: 10px 24px;
      border: 1px solid #444;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
    }
    .btn-cancel:hover, .btn-discard:hover {
      color: #ff4757;
      border-color: #ff4757;
    }
    .btn-report {
      background: #2ed573;
      color: black;
      padding: 10px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
    }
    .btn-report:hover { background: #7bed9f; }
    .btn-new-search {
      background: transparent;
      color: #888;
      padding: 10px 24px;
      border: 1px solid #444;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-family: inherit;
    }
    .btn-new-search:hover { color: #fff; border-color: #666; }
    /* Keep old paused card classes for compatibility */
    .paused-session-card { display: none !important; }

    /* Recent Sessions Panel */
    .recent-sessions-panel {
      max-width: 900px;
      margin: 0 auto 24px auto;
      background: #111;
      border-radius: 8px;
      padding: 16px;
      border: 1px solid #222;
    }
    .recent-sessions-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .recent-sessions-header h3 {
      margin: 0;
      font-size: 14px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .clear-history-btn {
      background: none;
      border: none;
      color: #555;
      cursor: pointer;
      font-size: 11px;
      font-family: inherit;
    }
    .clear-history-btn:hover { color: #ff4757; }
    .recent-session-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: #0a0a0a;
      border-radius: 6px;
      margin-bottom: 8px;
      border: 1px solid #1a1a1a;
    }
    .recent-session-item:last-child { margin-bottom: 0; }
    .session-info { flex: 1; }
    .session-name { font-weight: 600; color: #e0e0e0; font-size: 15px; }
    .session-meta { font-size: 11px; color: #555; margin-top: 4px; }
    .session-status {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      margin-right: 8px;
      text-transform: uppercase;
    }
    .status-in-progress { background: #332b00; color: #ffa502; }
    .status-complete { background: #1a2d1a; color: #2ed573; }
    .status-expired { background: #2d1a1a; color: #ff4757; }
    .session-actions { display: flex; gap: 8px; }
    .session-actions button {
      padding: 8px 14px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 11px;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .resume-btn { background: #fff; color: #000; }
    .resume-btn:hover { background: #e0e0e0; }
    .delete-btn { background: #1a1a1a; color: #666; border: 1px solid #333 !important; }
    .delete-btn:hover { background: #222; color: #888; }
  </style>
</head>
<body>
  <nav class="top-nav">
    <div class="nav-links">
      <a href="/" class="nav-link active">Screening</a>
      <a href="/ipo" class="nav-link">IPO Tracker</a>
    </div>
  </nav>
  <div class="main-content">
    <div class="container">
      <header>
        <img src="/logo.png" alt="DD Owl" class="header-logo">
        <div class="logo">DD OWL</div>
        <p class="subtitle">Red Flag Detector</p>
      </header>

      <!-- Progress Card - shows running/paused/complete states -->
      <div id="progressCard" class="progress-card" style="display: none;">
        <div class="progress-header">
          <div class="progress-title">
            <span class="status-icon" id="progressIcon"></span>
            <span id="progressLabel">Screening:</span>
            <strong id="progressName"></strong>
          </div>
          <div class="progress-percentage" id="progressPercentage">0%</div>
        </div>
        <div class="progress-bar-container">
          <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>
        <div class="progress-stats" id="progressStats">0 RED, 0 AMBER found</div>
        <div class="progress-actions" id="progressActions">
          <!-- Actions dynamically updated based on state -->
          <button onclick="pauseSearch()" class="btn-pause" id="pauseBtn">Pause</button>
          <button onclick="cancelSearch()" class="btn-cancel" id="cancelBtn">Cancel</button>
        </div>
      </div>

      <!-- Legacy paused session card - hidden -->
      <div id="pausedSessionCard" class="paused-session-card" style="display: none;"></div>

      <div class="search-box">
        <!-- Main row: Name + Language + Screen -->
        <div class="input-group">
          <input
            type="text"
            id="nameInput"
            placeholder="Enter subject name (e.g., 陈大文)"
            maxlength="20"
          >
          <div class="language-selector" id="languageSelector">
            <button type="button" class="language-btn" onclick="toggleLanguageDropdown(event)">
              <span class="lang-name" id="selectedLangName">中文</span>
              <span class="lang-arrow">▼</span>
            </button>
            <div class="language-dropdown">
              <input type="text" class="lang-search" placeholder="Search..." oninput="filterLanguages(this.value)">
              <div class="lang-list" id="langList"></div>
            </div>
          </div>
          <button class="btn-primary" id="searchBtn" onclick="startScreening()">
            Screen
          </button>
          <button class="btn-secondary" id="addToQueueBtn" onclick="addToQueue()" title="Add to queue">+</button>
        </div>

        <!-- Name Variations Section -->
        <div style="margin-top: 16px;">
          <label style="display: block; font-size: 11px; color: #666; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Name Variations</label>
          <div id="variationsContainer">
            <div class="variation-row" style="display: flex; gap: 8px; margin-bottom: 8px;">
              <input
                type="text"
                class="variation-input"
                placeholder="e.g., Chan Tai Man"
                style="flex: 1;"
              >
              <button type="button" onclick="removeVariation(this)" style="padding: 10px 14px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; color: #666; cursor: pointer; font-size: 16px;" title="Remove">×</button>
            </div>
          </div>
          <button type="button" onclick="addVariation()" style="padding: 10px 16px; background: transparent; border: 1px dashed #333; border-radius: 6px; color: #666; cursor: pointer; font-size: 13px; width: 100%; transition: all 0.2s;" onmouseover="this.style.borderColor='#555'; this.style.color='#999'" onmouseout="this.style.borderColor='#333'; this.style.color='#666'">+ Add variation</button>
        </div>
      </div>

      <!-- Queue Panel -->
      <div class="queue-panel" id="queuePanel" style="display: none;">
        <div class="queue-header">
          <span class="queue-title">Queue (<span id="queueCount">0</span>)</span>
          <button class="queue-toggle" onclick="toggleQueuePanel()">▼</button>
        </div>
        <div class="queue-body" id="queueBody">
          <div class="queue-list" id="queueList"></div>
          <div class="queue-actions">
            <button class="btn-secondary btn-sm" onclick="clearQueue()">Clear Queued</button>
            <button class="btn-secondary btn-sm" onclick="clearCompletedQueue()">Clear Done</button>
            <button class="btn-primary btn-sm" onclick="runNextInQueue()">Run Next</button>
          </div>
        </div>
      </div>

      <div class="results-section" id="resultsSection">
        <div class="stats" style="grid-template-columns: repeat(2, 1fr);">
          <div class="stat-card red">
            <div class="stat-number" id="redCount">0</div>
            <div class="stat-label">Potential Flags</div>
          </div>
          <div class="stat-card amber">
            <div class="stat-number" id="amberCount">0</div>
            <div class="stat-label">Potential Flags</div>
          </div>
        </div>

        <div class="flags-list" id="redFlags">
          <div class="flags-header red">Potential Flags</div>
          <div id="redFlagsList"></div>
        </div>

        <div class="flags-list" id="amberFlags">
          <div class="flags-header amber">Potential Flags</div>
          <div id="amberFlagsList"></div>
        </div>

        <div class="action-box">
          <div class="action-title">Recommended Action</div>
          <div class="action-text" id="actionText"></div>
        </div>

        <div style="display: flex; gap: 12px; margin-top: 20px;">
          <button class="btn-generate" id="generateReportBtn" onclick="generateDetailedReport()" disabled style="flex: 1;">
            Generate Report (<span id="selectedCount">0</span>)
          </button>
          <button class="btn-secondary" id="furtherSearchBtn" onclick="furtherSearchSelected()" disabled style="flex: 1;">
            Further Searches
          </button>
        </div>
        <button class="btn-further-links" id="furtherLinksBtn" onclick="openFurtherLinksModal()" style="display: none; margin-top: 12px; width: 100%;">
          Further Links (<span id="furtherLinksCount">0</span>)
        </button>
      </div>
    </div>
  </div>

  <!-- Further Links Modal -->
  <div class="further-links-modal" id="furtherLinksModal" style="display: none;">
    <div class="further-links-content">
      <div class="further-links-header">
        <span>Further Links</span>
        <button onclick="closeFurtherLinksModal()" style="background: none; border: none; color: #888; font-size: 20px; cursor: pointer;">&times;</button>
      </div>
      <div class="further-links-list" id="furtherLinksList"></div>
    </div>
  </div>

  <!-- Detailed Report Modal -->
  <div class="detail-report-modal" id="detailReportModal">
    <div class="report-modal-header">
      <span class="report-modal-title">Detailed Report</span>
      <div class="report-modal-status" id="detailReportStatus">
        <div class="status-dot"></div>
        <span>Generating...</span>
      </div>
      <button class="report-modal-close" onclick="closeDetailReportModal()">Close</button>
    </div>
    <div class="report-modal-body">
      <div id="detailReportContent" style="max-width: 800px; margin: 0 auto;"></div>
    </div>
    <div class="report-modal-footer">
      <button class="btn-secondary" id="copyDetailReportBtn" onclick="copyDetailReport()" disabled>
        Copy to Clipboard
      </button>
    </div>
  </div>

  <!-- Report Generation Modal -->
  <div class="report-modal" id="reportModal">
    <div class="report-modal-header">
      <span class="report-modal-title" id="reportModalTitle">Generating Report...</span>
      <div class="report-modal-status" id="reportModalStatus">
        <div class="status-dot"></div>
        <span>Writing...</span>
      </div>
      <button class="report-modal-close" onclick="closeReportModal()">Close</button>
    </div>
    <div class="report-modal-body">
      <div class="report-content" id="reportContent"></div>
    </div>
    <div class="report-modal-footer">
      <button class="btn-secondary" id="copyReportBtn" onclick="copyReport()" disabled>
        Copy to Clipboard
      </button>
      <button class="btn-primary" id="downloadWordBtn" onclick="downloadWord()" disabled>
        Download Word
      </button>
    </div>
  </div>

  <!-- Activity Log Panel -->
  <div class="activity-panel" id="activityPanel">
    <div class="activity-resize-handle" id="activityResizeHandle"></div>
    <div class="activity-header">
      <span class="activity-title">Activity Log</span>
      <button class="copy-log-btn" onclick="copyActivityLog()" title="Copy log to clipboard">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
      </button>
      <div class="activity-status">
        <div class="status-dot" id="statusDot"></div>
        <span class="activity-stats" id="activityStats">Ready</span>
      </div>
    </div>
    <div class="activity-log" id="activityLog"></div>
  </div>

  <div class="bottom-controls">
    <button class="toggle-panel hidden" id="togglePanel" onclick="toggleActivityPanel()">
      Show Log
    </button>
    <button class="disconnect-btn" id="disconnectBtn" onclick="disconnectScreening()" style="display: none;">
      Disconnect
    </button>
    <button class="resume-btn" id="resumeBtn" onclick="resumeScreening()" style="display: none;">
      Resume
    </button>
  </div>

  <script>
    let currentReport = null;
    let redCount = 0;
    let amberCount = 0;
    let greenCount = 0;
    let logEntries = 0;
    let urlsProcessed = 0;
    let furtherLinks = []; // Content mismatch items for manual review
    let sessionId = null; // For SSE reconnection (stored in Redis on server)

    // ============================================================
    // SESSION HISTORY MANAGER - LocalStorage for recent sessions
    // ============================================================
    const SessionHistory = {
      STORAGE_KEY: 'ddowl_recent_sessions',
      MAX_SESSIONS: 10,

      // Get all recent sessions
      getAll() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEY);
          return data ? JSON.parse(data) : [];
        } catch (e) {
          console.error('Failed to read session history:', e);
          return [];
        }
      },

      // Save a session to history
      save(session) {
        const sessions = this.getAll();
        // Remove existing entry for same sessionId
        const filtered = sessions.filter(s => s.sessionId !== session.sessionId);
        // Add new session at front
        filtered.unshift({
          sessionId: session.sessionId,
          subjectName: session.subjectName,
          language: session.language || 'en',
          startTime: session.startTime || Date.now(),
          lastAccess: Date.now(),
          status: session.status || 'in_progress',
          phase: session.phase || 'gather',
          findingsCount: session.findingsCount || 0,
        });
        // Keep only MAX_SESSIONS
        const trimmed = filtered.slice(0, this.MAX_SESSIONS);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(trimmed));
      },

      // Update session status
      update(sessionId, updates) {
        const sessions = this.getAll();
        const idx = sessions.findIndex(s => s.sessionId === sessionId);
        if (idx !== -1) {
          sessions[idx] = { ...sessions[idx], ...updates, lastAccess: Date.now() };
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(sessions));
        }
      },

      // Remove a session
      remove(sessionId) {
        const sessions = this.getAll().filter(s => s.sessionId !== sessionId);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(sessions));
      },

      // Clear all sessions
      clear() {
        localStorage.removeItem(this.STORAGE_KEY);
      }
    };

    // ============================================================
    // MULTI-TAB SYNC - BroadcastChannel for tab-to-tab communication
    // ============================================================
    const ScreeningSync = {
      channel: null,
      isLeader: false,
      sessionId: null,
      lastHeartbeat: 0,
      heartbeatInterval: null,
      watchdogInterval: null,
      screeningState: 'idle', // 'idle' | 'running' | 'paused' | 'cancelled'

      init(sessionId) {
        this.cleanup(); // Clean up any previous channel
        this.sessionId = sessionId;
        this.channel = new BroadcastChannel(`ddowl-screening-${sessionId}`);
        this.channel.onmessage = (e) => this.handleMessage(e.data);
      },

      handleMessage(data) {
        // Leader responds to pings
        if (data.type === 'ping' && this.isLeader) {
          this.channel.postMessage({
            type: 'pong',
            state: this.getCurrentState()
          });
          return;
        }

        // Follower receives state from leader
        if (data.type === 'pong' && !this.isLeader) {
          this.applyState(data.state);
          return;
        }

        // Follower receives progress updates
        if (data.type === 'progress' && !this.isLeader) {
          this.handleProgressEvent(data.event);
          return;
        }

        // Follower receives heartbeat
        if (data.type === 'heartbeat') {
          this.lastHeartbeat = Date.now();
          return;
        }

        // Leader is closing - take over
        if (data.type === 'leader_closing') {
          console.log('[SYNC] Leader closing, becoming leader...');
          this.becomeLeader();
          resumeScreening();
          return;
        }

        // Any tab receives state change
        if (data.type === 'state_change') {
          this.screeningState = data.state;
          updateProgressCard(data.state, data.progress, data.redCount, data.amberCount, data.subjectName);
          return;
        }
      },

      getCurrentState() {
        return {
          screeningState: this.screeningState,
          progress: progressState.percentage,
          redCount: redCount,
          amberCount: amberCount,
          greenCount: greenCount,
          subjectName: currentSubjectName || localStorage.getItem('ddowl_sessionName') || '',
          activityLog: Array.from(document.getElementById('activityLog').children).map(el => el.outerHTML),
          findings: {
            red: Array.from(document.getElementById('redFlagsList').children).map(el => el.outerHTML),
            amber: Array.from(document.getElementById('amberFlagsList').children).map(el => el.outerHTML)
          }
        };
      },

      applyState(state) {
        // Update progress bar with actual state
        this.screeningState = state.screeningState || 'running';
        updateProgressCard(this.screeningState, state.progress, state.redCount, state.amberCount, state.subjectName);

        // Update progressState so broadcasts have correct values
        progressState.percentage = state.progress;
        progressState.redCount = state.redCount;
        progressState.amberCount = state.amberCount;
        progressState.subjectName = state.subjectName;

        // Update counts
        redCount = state.redCount;
        amberCount = state.amberCount;
        greenCount = state.greenCount;
        currentSubjectName = state.subjectName;

        // Restore activity log
        const logEl = document.getElementById('activityLog');
        logEl.innerHTML = state.activityLog.join('');

        // Restore findings
        document.getElementById('redFlagsList').innerHTML = state.findings.red.join('');
        document.getElementById('amberFlagsList').innerHTML = state.findings.amber.join('');
        document.getElementById('redCount').textContent = state.redCount;
        document.getElementById('amberCount').textContent = state.amberCount;

        // Show activity panel
        document.getElementById('activityPanel').classList.add('active');
        document.getElementById('togglePanel').classList.remove('hidden');
      },

      handleProgressEvent(eventData) {
        // Process event exactly like SSE handler does
        processSSEEvent(eventData);
      },

      broadcast(eventData) {
        if (this.isLeader && this.channel) {
          this.channel.postMessage({ type: 'progress', event: eventData });
        }
      },

      broadcastState(newState) {
        this.screeningState = newState;
        if (this.channel) {
          this.channel.postMessage({
            type: 'state_change',
            state: newState,
            progress: progressState.percentage,
            redCount: progressState.redCount,
            amberCount: progressState.amberCount,
            subjectName: progressState.subjectName
          });
        }
      },

      becomeLeader() {
        this.isLeader = true;
        this.startHeartbeat();

        // Announce closing when tab closes
        window.addEventListener('beforeunload', () => {
          if (this.isLeader && this.channel) {
            this.channel.postMessage({ type: 'leader_closing', sessionId: this.sessionId });
          }
        });
      },

      startHeartbeat() {
        if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = setInterval(() => {
          if (this.isLeader && this.channel) {
            this.channel.postMessage({ type: 'heartbeat' });
          }
        }, 2000);
      },

      startWatchdog() {
        this.lastHeartbeat = Date.now();
        if (this.watchdogInterval) clearInterval(this.watchdogInterval);
        this.watchdogInterval = setInterval(() => {
          if (!this.isLeader && Date.now() - this.lastHeartbeat > 5000) {
            console.log('[SYNC] Leader died, taking over...');
            this.becomeLeader();
            resumeScreening();
          }
        }, 1000);
      },

      async checkForLeader(sessionId) {
        return new Promise((resolve) => {
          this.init(sessionId);
          let responded = false;

          const originalHandler = this.channel.onmessage;
          this.channel.onmessage = (e) => {
            if (e.data.type === 'pong') {
              responded = true;
              this.channel.onmessage = originalHandler;
              resolve({ hasLeader: true, state: e.data.state });
            }
          };

          this.channel.postMessage({ type: 'ping' });

          setTimeout(() => {
            if (!responded) {
              this.channel.onmessage = originalHandler;
              resolve({ hasLeader: false });
            }
          }, 500);
        });
      },

      cleanup() {
        if (this.heartbeatInterval) clearInterval(this.heartbeatInterval);
        if (this.watchdogInterval) clearInterval(this.watchdogInterval);
        if (this.channel) this.channel.close();
        this.isLeader = false;
        this.sessionId = null;
        this.channel = null;
      }
    };

    // ============================================================
    // QUEUE MANAGER - LocalStorage for multi-subject queue
    // ============================================================
    const QueueManager = {
      STORAGE_KEY: 'ddowl_queue',

      getAll() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEY);
          return data ? JSON.parse(data) : [];
        } catch {
          return [];
        }
      },

      add(subject) {
        const queue = this.getAll();
        const newItem = {
          id: `q_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
          subjectName: subject.name,
          variants: subject.variants || [],
          language: subject.language || 'chinese',
          status: 'queued', // queued | running | complete | error
          sessionId: null,
          progress: 0,
          createdAt: Date.now(),
          completedAt: null,
          stats: null // { red, amber, green }
        };
        queue.push(newItem);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(queue));
        return newItem;
      },

      update(id, updates) {
        const queue = this.getAll();
        const idx = queue.findIndex(q => q.id === id);
        if (idx !== -1) {
          queue[idx] = { ...queue[idx], ...updates };
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(queue));
        }
      },

      remove(id) {
        const queue = this.getAll().filter(q => q.id !== id);
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(queue));
      },

      getNext() {
        return this.getAll().find(q => q.status === 'queued');
      },

      hasRunning() {
        return this.getAll().some(q => q.status === 'running');
      },

      clear() {
        localStorage.removeItem(this.STORAGE_KEY);
      },

      // Clear only queued items (not completed or running)
      clearQueued() {
        const queue = this.getAll().filter(q => q.status !== 'queued');
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(queue));
      },

      // Clear only completed items
      clearCompleted() {
        const queue = this.getAll().filter(q => q.status !== 'complete');
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(queue));
      }
    };

    // ============================================================
    // QUEUE PANEL RENDERING - Display and manage queue UI
    // ============================================================
    function renderQueue() {
      const queue = QueueManager.getAll();
      const panel = document.getElementById('queuePanel');
      const list = document.getElementById('queueList');
      const count = document.getElementById('queueCount');

      // Show/hide panel based on queue length
      if (queue.length === 0) {
        panel.style.display = 'none';
        return;
      }

      panel.style.display = 'block';
      count.textContent = queue.length;

      list.innerHTML = queue.map(item => {
        const isComplete = item.status === 'complete';
        const hasFindings = isComplete && item.findings?.length > 0;
        const statsHtml = item.stats
          ? `<span class="queue-item-stats"><span class="red-count">${item.stats.red}R</span> <span class="amber-count">${item.stats.amber}A</span></span>`
          : '';

        return `
          <div class="queue-item ${item.status}${hasFindings ? ' clickable' : ''}"${hasFindings ? ` onclick="viewQueueResults('${item.id}')"` : ''}>
            <div class="queue-item-main">
              <span class="queue-item-name">${escapeHtml(item.subjectName)}</span>
              ${item.variants?.length ? `<span style="color:#666;font-size:11px;margin-left:8px;">(+${item.variants.length} variants)</span>` : ''}
              ${isComplete ? statsHtml : ''}
            </div>
            <div class="queue-item-actions">
              ${item.status === 'running' ? `<span class="queue-item-status running">${item.progress || 0}%</span>` : ''}
              ${item.status === 'queued' ? `<span class="queue-item-status">queued</span>` : ''}
              ${item.status === 'error' ? `<span class="queue-item-status error">error</span>` : ''}
              ${hasFindings ? `<button class="btn-view" onclick="event.stopPropagation(); viewQueueResults('${item.id}')">View</button>` : ''}
              <button class="btn-remove" onclick="event.stopPropagation(); removeQueueItem('${item.id}')" title="Remove">×</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // View results from a completed queue item
    function viewQueueResults(itemId) {
      const queue = QueueManager.getAll();
      const item = queue.find(q => q.id === itemId);

      if (!item || !item.findings || item.findings.length === 0) {
        console.log('[Queue] No findings for item:', itemId);
        return;
      }

      // Clear current results display
      document.getElementById('redFlagsList').innerHTML = '';
      document.getElementById('amberFlagsList').innerHTML = '';
      redCount = 0;
      amberCount = 0;
      document.getElementById('redCount').textContent = '0';
      document.getElementById('amberCount').textContent = '0';
      selectedFindings.clear();
      updateSelectedCount();

      // Load saved findings
      currentFindings = item.findings;
      currentSubjectName = item.subjectName;

      // Re-render each finding
      currentFindings.forEach((finding, index) => {
        addConsolidatedResultToUI(finding, index);
      });

      // Update subject display
      const subjectDisplay = document.getElementById('subjectNameDisplay');
      if (subjectDisplay) {
        subjectDisplay.textContent = item.subjectName;
      }

      // Show results section
      document.getElementById('resultsSection').classList.add('active');

      // Scroll to results
      document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
    }

    // Remove a single queue item
    function removeQueueItem(itemId) {
      QueueManager.remove(itemId);
      renderQueue();
    }

    function toggleQueuePanel() {
      const body = document.getElementById('queueBody');
      const toggle = document.querySelector('.queue-toggle');
      if (body.style.display === 'none') {
        body.style.display = 'block';
        toggle.textContent = '▼';
      } else {
        body.style.display = 'none';
        toggle.textContent = '▶';
      }
    }

    function clearQueue() {
      if (confirm('Clear all queued (pending) subjects?')) {
        QueueManager.clearQueued();
        renderQueue();
      }
    }

    function clearCompletedQueue() {
      if (confirm('Clear all completed screenings?')) {
        QueueManager.clearCompleted();
        renderQueue();
      }
    }

    // Restore queue state on page load - check if running items are still alive on server
    async function restoreQueueState() {
      const queue = QueueManager.getAll();

      for (const item of queue) {
        if (item.status === 'running' && item.sessionId) {
          // Check if session is still alive on server
          try {
            const resp = await fetch(`/api/session/${item.sessionId}/status`);
            if (resp.ok) {
              const status = await resp.json();
              if (!status.exists) {
                // Session expired or not found
                QueueManager.update(item.id, { status: 'error' });
              } else if (status.phase === 'complete') {
                QueueManager.update(item.id, {
                  status: 'complete',
                  stats: status.stats
                });
              }
              // If still running on server, leave as 'running' - user can resume
            } else {
              // HTTP error
              QueueManager.update(item.id, { status: 'error' });
            }
          } catch {
            QueueManager.update(item.id, { status: 'error' });
          }
        }
      }

      renderQueue();
    }

    // ============================================================
    // QUEUE SEQUENTIAL RUNNER - Process queue items one at a time
    // ============================================================
    let currentQueueItemId = null;

    function runNextInQueue(force = false) {
      // Don't start if something is already running (unless forced)
      if (QueueManager.hasRunning()) {
        if (!force) {
          // If user clicks Run Next while something shows as running,
          // check if it's actually running or stuck
          const running = QueueManager.getAll().find(q => q.status === 'running');
          if (running && !currentQueueItemId) {
            // Item shows as running but we're not tracking it - it's stuck
            console.log('[Queue] Found stuck running item, marking as error:', running.id);
            QueueManager.update(running.id, { status: 'error' });
            renderQueue();
            // Now try again
            runNextInQueue();
            return;
          }
          // Actually running something
          addLogEntry('warn', '[Queue] A screening is already running');
          return;
        }
      }

      const next = QueueManager.getNext();
      if (!next) {
        const allItems = QueueManager.getAll();
        const queuedCount = allItems.filter(i => i.status === 'queued').length;
        const runningCount = allItems.filter(i => i.status === 'running').length;
        const completeCount = allItems.filter(i => i.status === 'complete').length;

        if (allItems.length === 0) {
          addLogEntry('info', '[Queue] Queue is empty. Add subjects using the + button.');
        } else if (queuedCount === 0 && completeCount > 0) {
          addLogEntry('info', `[Queue] All ${completeCount} subjects completed. Add more or click completed items to view results.`);
        } else if (runningCount > 0) {
          addLogEntry('warn', '[Queue] A screening is in progress.');
        } else {
          addLogEntry('info', '[Queue] No queued subjects. Add subjects using the + button.');
        }
        console.log('[Queue] All items:', allItems.map(i => ({ id: i.id, name: i.subjectName, status: i.status })));
        return;
      }

      console.log('[Queue] Starting next item:', next.subjectName, next.id);
      addLogEntry('info', `[Queue] Starting: ${next.subjectName}`);

      // Mark as running - persist to localStorage for reconnection recovery
      currentQueueItemId = next.id;
      localStorage.setItem('ddowl_queueItemId', next.id);
      QueueManager.update(next.id, { status: 'running' });
      renderQueue();

      // Set up the input as if user typed it (for existing startScreening logic)
      document.getElementById('nameInput').value = next.subjectName;

      // Clear existing variations and add from queue item
      document.querySelectorAll('.variation-input').forEach(input => {
        input.value = '';
      });
      if (next.variants?.length) {
        // Add variations to the first available inputs
        const variationInputs = document.querySelectorAll('.variation-input');
        next.variants.forEach((v, i) => {
          if (variationInputs[i]) variationInputs[i].value = v;
        });
      }

      selectedLanguage = next.language || 'chinese';

      // Start screening
      startScreening();
    }

    // ============================================================
    // URL HASH ROUTER - For shareable session URLs
    // ============================================================
    const Router = {
      // Get session ID from URL hash (e.g., /#/session/abc123)
      getSessionIdFromUrl() {
        const hash = window.location.hash;
        const match = hash.match(/^#\/session\/([a-zA-Z0-9-]+)$/);
        return match ? match[1] : null;
      },

      // Update URL to session URL (without page reload)
      setSessionUrl(sessionId) {
        const newUrl = `${window.location.pathname}#/session/${sessionId}`;
        window.history.pushState({ sessionId }, '', newUrl);
      },

      // Clear session from URL (go to homepage)
      clearSessionUrl() {
        window.history.pushState({}, '', window.location.pathname);
      },

      // Check if we're on homepage (no session in URL)
      isHomepage() {
        return !this.getSessionIdFromUrl();
      }
    };

    // ============================================================
    // RECENT SESSIONS UI - Render and manage recent sessions panel
    // ============================================================

    // Helper: time ago formatting
    function getTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      return `${Math.floor(seconds / 86400)}d ago`;
    }

    // Helper: escape HTML to prevent XSS
    function escapeHtmlForSessions(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Render recent sessions panel
    async function renderRecentSessions() {
      const panel = document.getElementById('recent-sessions-panel');
      const list = document.getElementById('recent-sessions-list');
      if (!panel || !list) return;

      const sessions = SessionHistory.getAll();

      if (sessions.length === 0) {
        panel.style.display = 'none';
        return;
      }

      // Validate sessions against backend (check if still exists)
      const validatedSessions = await Promise.all(sessions.map(async (s) => {
        try {
          const resp = await fetch(`/api/session/${s.sessionId}/status`);
          const data = await resp.json();
          if (data.exists) {
            return { ...s, status: data.phase === 'complete' ? 'complete' : 'in_progress', phase: data.phase, findingsCount: data.findingsCount || 0, progress: data.progress };
          } else {
            return { ...s, status: 'expired' };
          }
        } catch (e) {
          return { ...s, status: 'unknown' };
        }
      }));

      // Update localStorage with validated data
      validatedSessions.forEach(s => {
        if (s.status === 'expired') {
          SessionHistory.update(s.sessionId, { status: 'expired' });
        } else if (s.status !== 'unknown') {
          SessionHistory.update(s.sessionId, { status: s.status, phase: s.phase, findingsCount: s.findingsCount });
        }
      });

      // Render HTML
      list.innerHTML = validatedSessions.map(s => {
        const timeAgo = getTimeAgo(s.startTime);
        const statusClass = s.status === 'complete' ? 'status-complete' :
                            s.status === 'expired' ? 'status-expired' : 'status-in-progress';
        const statusText = s.status === 'complete' ? `Complete - ${s.findingsCount || 0} findings` :
                           s.status === 'expired' ? 'Expired' :
                           s.progress || `In Progress (${s.phase || 'processing'})`;
        const actionBtn = s.status === 'expired'
          ? `<button class="resume-btn" onclick="startNewSearchFor('${escapeHtmlForSessions(s.subjectName)}')">Search Again</button>`
          : `<button class="resume-btn" onclick="resumeSessionFromHistory('${s.sessionId}')">Resume</button>`;

        return `
          <div class="recent-session-item">
            <div class="session-info">
              <div class="session-name">${escapeHtmlForSessions(s.subjectName)}</div>
              <div class="session-meta">
                <span class="session-status ${statusClass}">${statusText}</span>
                Started ${timeAgo}
              </div>
            </div>
            <div class="session-actions">
              ${actionBtn}
              <button class="delete-btn" onclick="removeFromHistory('${s.sessionId}')">Remove</button>
            </div>
          </div>
        `;
      }).join('');

      panel.style.display = 'block';
    }

    // Remove session from history
    function removeFromHistory(sid) {
      SessionHistory.remove(sid);
      renderRecentSessions();
    }

    // Start new search for a given subject name
    function startNewSearchFor(subjectName) {
      document.getElementById('nameInput').value = subjectName;
      startScreening();
    }

    // Resume session from history panel
    async function resumeSessionFromHistory(sid) {
      // Get session info from history to populate name field
      const sessions = SessionHistory.getAll();
      let session = sessions.find(s => s.sessionId === sid);

      // If not in localStorage, fetch from server (e.g., direct URL or popstate)
      if (!session) {
        try {
          const resp = await fetch(`/api/session/${sid}/status`);
          const data = await resp.json();
          if (data.exists) {
            session = { subjectName: data.subjectName };
          } else {
            alert('Session not found or expired.');
            Router.clearSessionUrl();
            return;
          }
        } catch (e) {
          alert('Failed to load session');
          return;
        }
      }

      // Set up state for resume
      sessionId = sid;
      Router.setSessionUrl(sid);
      document.getElementById('nameInput').value = session.subjectName;

      // Hide recent sessions panel
      document.getElementById('recent-sessions-panel').style.display = 'none';

      // Fetch and display existing findings before reconnecting
      try {
        const findingsResponse = await fetch(`/api/session/${sid}/findings`);
        const findingsData = await findingsResponse.json();
        if (findingsData.findings && findingsData.findings.length > 0) {
          // Clear any existing findings in UI first
          document.getElementById('redFlagsList').innerHTML = '';
          document.getElementById('amberFlagsList').innerHTML = '';

          // Add each finding to UI using consolidated format (has sources, dateRange, etc.)
          findingsData.findings.forEach((finding, index) => {
            addConsolidatedResultToUI(finding, index);
          });
          addLogEntry('result', `Restored ${findingsData.findings.length} findings from previous session`);
        }
      } catch (e) {
        console.warn('Could not restore findings:', e);
      }

      // Call startScreening which handles reconnection properly
      startScreening();
    }

    // Clear history button handler
    document.addEventListener('DOMContentLoaded', () => {
      const clearBtn = document.getElementById('clear-history-btn');
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          if (confirm('Clear all recent searches?')) {
            SessionHistory.clear();
            renderRecentSessions();
          }
        });
      }
    });

    // Language Selector - native names, grouped by region
    const LANGUAGES = [
      // East Asia
      { code: 'chinese', name: '中文', enabled: true },
      { code: 'japanese', name: '日本語', enabled: false },
      { code: 'korean', name: '한국어', enabled: false },
      // Southeast Asia
      { code: 'thai', name: 'ไทย', enabled: false },
      { code: 'vietnamese', name: 'Tiếng Việt', enabled: false },
      { code: 'indonesian', name: 'Bahasa Indonesia', enabled: false },
      { code: 'malay', name: 'Bahasa Melayu', enabled: false },
      { code: 'khmer', name: 'ខ្មែរ', enabled: false },
      { code: 'burmese', name: 'မြန်မာ', enabled: false },
      { code: 'tagalog', name: 'Tagalog', enabled: false },
      { code: 'lao', name: 'ລາວ', enabled: false },
      // South Asia
      { code: 'hindi', name: 'हिन्दी', enabled: false },
      { code: 'tamil', name: 'தமிழ்', enabled: false },
      // Europe
      { code: 'english', name: 'English', enabled: false },
      { code: 'german', name: 'Deutsch', enabled: false },
      { code: 'french', name: 'Français', enabled: false },
      { code: 'spanish', name: 'Español', enabled: false },
      { code: 'portuguese', name: 'Português', enabled: false },
      { code: 'russian', name: 'Русский', enabled: false },
      // Middle East
      { code: 'arabic', name: 'العربية', enabled: false },
    ];

    let selectedLanguage = 'chinese';

    function toggleLanguageDropdown(e) {
      e.stopPropagation();
      document.getElementById('languageSelector').classList.toggle('open');
    }

    function selectLanguage(code) {
      const lang = LANGUAGES.find(l => l.code === code);
      if (!lang || !lang.enabled) return;

      selectedLanguage = code;
      document.getElementById('selectedLangName').textContent = lang.name;
      document.getElementById('languageSelector').classList.remove('open');
      renderLanguageList();
    }

    function filterLanguages(query) {
      renderLanguageList(query.toLowerCase());
    }

    function renderLanguageList(filter = '') {
      const list = document.getElementById('langList');
      const filtered = LANGUAGES.filter(l =>
        l.name.toLowerCase().includes(filter) || l.code.includes(filter)
      );

      list.innerHTML = filtered.map(lang => `
        <div class="lang-option ${lang.code === selectedLanguage ? 'selected' : ''} ${!lang.enabled ? 'disabled' : ''}"
             onclick="${lang.enabled ? `selectLanguage('${lang.code}')` : ''}">
          <span class="lang-label">${lang.name}</span>
          ${!lang.enabled ? '<span class="lang-badge">soon</span>' : ''}
          ${lang.code === selectedLanguage ? '<span class="lang-check">✓</span>' : ''}
        </div>
      `).join('');
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.language-selector')) {
        document.getElementById('languageSelector').classList.remove('open');
      }
    });

    // Handle browser back/forward navigation
    window.addEventListener('popstate', async () => {
      const urlSessionId = Router.getSessionIdFromUrl();
      if (urlSessionId) {
        // Resume this session via resumeSessionFromHistory
        await resumeSessionFromHistory(urlSessionId);
      } else {
        // Back to homepage - refresh recent sessions
        window.location.reload();
      }
    });

    // Initialize language list on page load + check for existing session + render recent sessions
    document.addEventListener('DOMContentLoaded', async () => {
      renderLanguageList();
      await restoreQueueState(); // Restore queue state and render (checks server for running items)

      // Check if we're resuming from a URL with session ID
      const urlSessionId = Router.getSessionIdFromUrl();
      if (urlSessionId) {
        // Resume from URL (could be direct link or bookmark)
        try {
          const resp = await fetch(`/api/session/${urlSessionId}/status`);
          const data = await resp.json();
          if (data.exists) {
            // Save to localStorage so resumeScreening() can find it
            localStorage.setItem('ddowl_sessionId', urlSessionId);
            localStorage.setItem('ddowl_sessionName', data.name || '');

            // Set up state for resume
            sessionId = urlSessionId;
            document.getElementById('nameInput').value = data.name || '';
            document.getElementById('recent-sessions-panel').style.display = 'none';

            // Call resumeScreening() instead of startScreening() - preserves sessionId!
            resumeScreening();
            return;
          } else {
            alert('Session not found or expired.');
            Router.clearSessionUrl();
          }
        } catch (e) {
          console.error('Failed to resume from URL:', e);
          Router.clearSessionUrl();
        }
      }

      // Check for paused session and show card if exists (with multi-tab sync)
      await checkForPausedSessionWithSync();
    });

    // ===== PROGRESS BAR SYSTEM =====
    // Phase weights for overall progress calculation
    const PHASE_WEIGHTS = {
      gather: { start: 0, weight: 15 },      // 0-15%
      eliminate: { start: 15, weight: 5 },   // 15-20%
      cluster: { start: 20, weight: 15 },    // 20-35%
      categorize: { start: 35, weight: 25 }, // 35-60%
      analyze: { start: 60, weight: 30 },    // 60-90%
      consolidate: { start: 90, weight: 10 } // 90-100%
    };

    // Current progress state
    let progressState = {
      percentage: 0,
      redCount: 0,
      amberCount: 0,
      subjectName: '',
      state: 'idle' // 'running', 'paused', 'complete'
    };

    // Calculate overall progress from phase and batch info
    function calculateOverallProgress(phase, batchCurrent, batchTotal) {
      const phaseInfo = PHASE_WEIGHTS[phase];
      if (!phaseInfo) return progressState.percentage; // Keep current if unknown phase

      const phaseProgress = batchTotal > 0 ? (batchCurrent / batchTotal) * 100 : 0;
      return Math.round((phaseInfo.start + (phaseProgress / 100) * phaseInfo.weight) * 10) / 10;
    }

    // Update the progress card UI
    function updateProgressCard(state, percentage, redCount, amberCount, subjectName) {
      const card = document.getElementById('progressCard');
      const fill = document.getElementById('progressBarFill');
      const pct = document.getElementById('progressPercentage');
      const stats = document.getElementById('progressStats');
      const nameEl = document.getElementById('progressName');
      const labelEl = document.getElementById('progressLabel');
      const iconEl = document.getElementById('progressIcon');
      const actionsEl = document.getElementById('progressActions');

      // Update state
      progressState = { percentage, redCount, amberCount, subjectName, state };

      // Show card
      card.style.display = 'block';
      card.className = 'progress-card ' + state;

      // Update content
      fill.style.width = percentage + '%';
      pct.textContent = percentage + '%';
      stats.textContent = `${redCount} RED, ${amberCount} AMBER found`;
      nameEl.textContent = subjectName;

      // Update based on state
      if (state === 'running') {
        iconEl.textContent = '';
        labelEl.textContent = 'Screening:';
        actionsEl.innerHTML = `
          <button onclick="pauseSearch()" class="btn-pause">Pause</button>
          <button onclick="cancelSearch()" class="btn-cancel">Cancel</button>
        `;
      } else if (state === 'paused') {
        iconEl.textContent = '🟡';
        labelEl.textContent = 'Paused:';
        actionsEl.innerHTML = `
          <button onclick="resumePausedSession()" class="btn-resume">Resume</button>
          <button onclick="discardPausedSession()" class="btn-discard">Discard</button>
        `;
      } else if (state === 'complete') {
        iconEl.textContent = '✓';
        labelEl.textContent = 'Complete:';
        actionsEl.innerHTML = `
          <button onclick="showReportModal()" class="btn-report">Generate Report</button>
          <button onclick="startNewSearch()" class="btn-new-search">New Search</button>
        `;
      }
    }

    // Hide the progress card
    function hideProgressCard() {
      document.getElementById('progressCard').style.display = 'none';
      progressState.state = 'idle';
    }

    // Start a new search (clears everything)
    function startNewSearch() {
      hideProgressCard();
      document.getElementById('nameInput').value = '';
      document.getElementById('resultsSection').classList.remove('active');
      sessionId = null;
      localStorage.removeItem('ddowl_sessionId');
      localStorage.removeItem('ddowl_sessionName');
    }

    // ===== END PROGRESS BAR SYSTEM =====

    // ===== SHARED SSE EVENT HANDLER =====
    // Used by both leader (SSE) and follower (BroadcastChannel) tabs
    function processSSEEvent(data, subjectName) {
      // Skip heartbeat
      if (data.type === 'heartbeat') return;

      // Get subject name from param or state
      const name = subjectName || currentSubjectName || localStorage.getItem('ddowl_sessionName') || '';

      // Handle phase events
      if (data.type === 'phase') {
        addLogEntry('search', `━━━ PHASE ${data.phase}: ${data.name} ━━━`);
        addLogEntry('search', data.message);
        updateActivityStats(`Phase ${data.phase}: ${data.name}`);
        const phaseName = data.name?.toLowerCase() || '';
        const phaseKey = phaseName.includes('gather') ? 'gather' :
                        phaseName.includes('eliminat') ? 'eliminate' :
                        phaseName.includes('cluster') ? 'cluster' :
                        phaseName.includes('categor') ? 'categorize' :
                        phaseName.includes('analyz') ? 'analyze' :
                        phaseName.includes('consolid') ? 'consolidate' : null;
        if (phaseKey && PHASE_WEIGHTS[phaseKey]) {
          updateProgressCard('running', PHASE_WEIGHTS[phaseKey].start, progressState.redCount, progressState.amberCount, name);
        }
      }

      if (data.type === 'phase_skipped') {
        addLogEntry('search', `Phase ${data.phase} skipped: ${data.reason}`);
      }

      // Handle search progress
      if (data.type === 'search_page') {
        const stopReason = data.pageResults === 0 ? ' → STOP (empty)' : (data.pageResults < 10 ? ' → STOP (last page)' : '');
        addLogEntry('search', `  Q${data.queryIndex} Page ${data.page}: ${data.pageResults} results${stopReason}`);
      }

      if (data.type === 'search_progress') {
        addLogEntry('search', `Query ${data.queryIndex}/${data.totalQueries} | ${data.resultsFound} results | ${data.query}`);
        updateActivityStats(`Searching ${data.queryIndex}/${data.totalQueries} (${data.totalSoFar} total)`);
        const pct = calculateOverallProgress('gather', data.queryIndex, data.totalQueries);
        updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
      }

      // Handle clustering
      if (data.type === 'cluster_batch_start') {
        addLogEntry('analyze', `  [Batch ${data.batch}/${data.totalBatches}] Clustering ${data.articlesInBatch} articles...`);
        updateActivityStats(`Clustering batch ${data.batch}/${data.totalBatches}`);
      }

      if (data.type === 'cluster_batch_complete') {
        const labels = data.clusterLabels?.slice(0, 5).join(', ') || '';
        const more = data.clusterLabels?.length > 5 ? ` (+${data.clusterLabels.length - 5} more)` : '';
        addLogEntry('analyze', `  [Batch ${data.batch}/${data.totalBatches}] Found ${data.clustersFound} incidents: ${labels}${more}`);
        const pct = calculateOverallProgress('cluster', data.batch, data.totalBatches);
        updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
      }

      if (data.type === 'cluster_merge_complete') {
        addLogEntry('result', `Merged to ${data.totalClusters} unique incidents`);
        if (data.clusterLabels && data.clusterLabels.length > 0) {
          const toShow = data.clusterLabels.slice(0, 10);
          toShow.forEach((label, i) => {
            addLogEntry('analyze', `  ${i + 1}. ${label}`);
          });
          if (data.clusterLabels.length > 10) {
            addLogEntry('analyze', `  ... and ${data.clusterLabels.length - 10} more incidents`);
          }
        }
      }

      if (data.type === 'incident_clusters') {
        addLogEntry('result', `━━━ CLUSTERING RESULT ━━━`);
        addLogEntry('result', `${data.totalArticles} articles → ${data.totalClusters} incidents`);
        addLogEntry('result', `Keeping ${data.articlesToAnalyze} for analysis, parking ${data.articlesParked} duplicates`);
        addLogEntry('analyze', `Duration: ${(data.duration/1000).toFixed(1)}s`);
      }

      // Handle phase_resumed
      if (data.type === 'phase_resumed') {
        if (data.partialResults) {
          progressState.redCount = data.partialResults.red || 0;
          progressState.amberCount = data.partialResults.amber || 0;
          updateProgressCard('running', progressState.percentage || 0, progressState.redCount, progressState.amberCount, name);
          addLogEntry('result', `Restored counts: ${progressState.redCount} RED, ${progressState.amberCount} AMBER from previous batches`);
        }
        addLogEntry('info', data.message || `Resuming ${data.phase} phase`);
      }

      // Handle categorization
      if (data.type === 'categorize_batch_complete') {
        addLogEntry('analyze', `Batch ${data.batch}/${data.totalBatches}: ${data.processedSoFar}/${data.totalItems} (${data.batchRed} RED, ${data.batchAmber} AMBER)`);
        updateActivityStats(`Categorizing ${data.processedSoFar}/${data.totalItems}...`);
        const pct = calculateOverallProgress('categorize', data.batch, data.totalBatches);
        progressState.redCount = (progressState.redCount || 0) + (data.batchRed || 0);
        progressState.amberCount = (progressState.amberCount || 0) + (data.batchAmber || 0);
        updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
      }

      if (data.type === 'categorize_complete') {
        addLogEntry('result', `Categorized: ${data.red} RED, ${data.amber} AMBER, ${data.green} GREEN`);
      }

      // Handle analyze
      if (data.type === 'analyze_start') {
        addLogEntry('fetch', `[${data.index}/${data.total}] Analyzing: ${data.title}`, data.url);
        const pct = calculateOverallProgress('analyze', data.index, data.total);
        updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
      }

      if (data.type === 'analyze_skip') {
        addLogEntry('analyze', `[${data.index}/${data.total}] Skipped: ${data.reason} | ${data.title}`, data.url);
        const pct = calculateOverallProgress('analyze', data.index, data.total);
        updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
      }

      if (data.type === 'analyze_result') {
        if (data.action === 'SKIP') {
          addLogEntry('analyze', `Cleared: ${data.reason}`, data.url);
        } else if (data.isAdverse) {
          const color = data.severity === 'RED' ? 'red' : 'amber';
          addLogEntry(color, `${data.severity}: ${data.headline}`, data.url);
          addResultToUI({
            url: data.url,
            title: data.title,
            severity: data.severity,
            summary: data.headline + ' - ' + data.summary
          });
          const newRed = progressState.redCount + (data.severity === 'RED' ? 1 : 0);
          const newAmber = progressState.amberCount + (data.severity === 'AMBER' ? 1 : 0);
          updateProgressCard('running', progressState.percentage, newRed, newAmber, name);
        } else {
          addLogEntry('green', `Clear`, data.url);
        }
      }

      // Handle paused event
      if (data.type === 'paused') {
        addLogEntry('warn', `Server paused at ${data.phase} phase`);
        updateActivityStats('Paused by server');
      }

      // Handle consolidation
      if (data.type === 'consolidating') {
        addLogEntry('fetch', `Consolidating ${data.count} findings...`);
        updateActivityStats('Consolidating...');
      }

      if (data.type === 'consolidated') {
        if (data.before !== data.after) {
          addLogEntry('result', `Consolidated: ${data.before} findings → ${data.after} unique incidents`);
        }
      }

      // Handle reconnection status
      if (data.type === 'reconnect_status') {
        addLogEntry('result', `✓ Reconnected. ${data.message}`);
        updateActivityStats(`Reconnected: ${data.phaseName} phase${data.progress ? ` (${data.progress})` : ''}`);
        if (data.findingsCount > 0) {
          addLogEntry('result', `  ${data.findingsCount} findings restored from previous session`);
        }
      }
    }
    // ===== END SHARED SSE EVENT HANDLER =====

    // Check for paused session with multi-tab sync support
    async function checkForPausedSessionWithSync() {
      const savedSessionId = localStorage.getItem('ddowl_sessionId');
      if (!savedSessionId) {
        return; // No session to check
      }

      // First, check if another tab is already running this session
      const { hasLeader, state } = await ScreeningSync.checkForLeader(savedSessionId);

      if (hasLeader) {
        // Another tab is running - become follower and show synced state
        console.log('[SYNC] Found leader, becoming follower');
        ScreeningSync.init(savedSessionId);
        ScreeningSync.applyState(state);
        ScreeningSync.startWatchdog();
        document.getElementById('nameInput').value = state.subjectName;
        document.getElementById('recent-sessions-panel').style.display = 'none';
        return;
      }

      // No leader - fall back to original paused session check
      await checkForPausedSession();
    }

    // Check localStorage for a paused session on page load
    async function checkForPausedSession() {
      const savedSessionId = localStorage.getItem('ddowl_sessionId');
      const savedName = localStorage.getItem('ddowl_sessionName');

      if (!savedSessionId || !savedName) {
        hideProgressCard();
        return;
      }

      try {
        const response = await fetch(`/api/session/${savedSessionId}/status`);
        const status = await response.json();

        if (status.exists && status.phase !== 'complete') {
          // Show paused progress card with estimated percentage
          const percentage = PHASE_WEIGHTS[status.phase]?.start || 0;
          const red = status.stats?.red || 0;
          const amber = status.stats?.amber || 0;
          updateProgressCard('paused', percentage, red, amber, savedName);
          // Show the "Show Log" button so user can view activity log
          document.getElementById('togglePanel').classList.remove('hidden');
        } else {
          // Session expired or completed, clear localStorage
          localStorage.removeItem('ddowl_sessionId');
          localStorage.removeItem('ddowl_sessionName');
          hideProgressCard();
        }
      } catch (e) {
        console.error('Failed to check session status:', e);
        hideProgressCard();
      }
    }

    // Discard paused session
    async function discardPausedSession() {
      const savedSessionId = localStorage.getItem('ddowl_sessionId');

      // Clear from localStorage
      localStorage.removeItem('ddowl_sessionId');
      localStorage.removeItem('ddowl_sessionName');
      sessionId = null;

      // Hide progress card
      hideProgressCard();

      // Delete from server too
      if (savedSessionId) {
        try {
          await fetch(`/api/session/${savedSessionId}`, { method: 'DELETE' });
        } catch (e) {
          console.error('Failed to delete session from server:', e);
        }
      }
    }

    // Pause active search
    async function pauseSearch() {
      if (!sessionId) return;

      // Tell server to pause
      try {
        await fetch(`/api/session/${sessionId}/pause`, { method: 'POST' });
      } catch (e) {
        console.error('Failed to pause:', e);
      }

      // Close SSE connection
      if (currentEventSource) {
        currentEventSource.close();
        currentEventSource = null;
      }
      if (currentHealthCheckInterval) {
        clearInterval(currentHealthCheckInterval);
        currentHealthCheckInterval = null;
      }

      // Update progress card to paused state
      updateProgressCard(
        'paused',
        progressState.percentage,
        progressState.redCount,
        progressState.amberCount,
        progressState.subjectName
      );

      addLogEntry('warn', 'Paused. Click Resume to continue.');
      ScreeningSync.broadcastState('paused');
    }

    // Cancel active search entirely
    async function cancelSearch() {
      const sid = sessionId;

      // Clear state
      sessionId = null;
      localStorage.removeItem('ddowl_sessionId');
      localStorage.removeItem('ddowl_sessionName');

      // Close SSE connection
      if (currentEventSource) {
        currentEventSource.close();
        currentEventSource = null;
      }
      if (currentHealthCheckInterval) {
        clearInterval(currentHealthCheckInterval);
        currentHealthCheckInterval = null;
      }

      // Hide progress card
      hideProgressCard();

      // Delete session from server
      if (sid) {
        try {
          await fetch(`/api/session/${sid}`, { method: 'DELETE' });
        } catch (e) {
          console.error('Failed to delete session:', e);
        }
      }

      addLogEntry('warn', 'Search cancelled.');
      ScreeningSync.broadcastState('cancelled');
    }

    // Resume paused session
    async function resumePausedSession() {
      const savedSessionId = localStorage.getItem('ddowl_sessionId');
      const savedName = localStorage.getItem('ddowl_sessionName');

      if (!savedSessionId || !savedName) return;

      // Clear pause flag on server
      try {
        await fetch(`/api/session/${savedSessionId}/resume`, { method: 'POST' });
      } catch (e) {
        console.error('Failed to clear pause flag:', e);
      }

      // Set up state
      sessionId = savedSessionId;
      document.getElementById('nameInput').value = savedName;

      // Hide paused card
      document.getElementById('pausedSessionCard').style.display = 'none';

      // Fetch and display existing findings before reconnecting SSE
      try {
        const findingsResponse = await fetch(`/api/session/${savedSessionId}/findings`);
        const findingsData = await findingsResponse.json();
        if (findingsData.findings && findingsData.findings.length > 0) {
          // Clear any existing findings in UI first
          document.getElementById('redFlagsList').innerHTML = '';
          document.getElementById('amberFlagsList').innerHTML = '';

          // Add each finding to UI using consolidated format (has sources, dateRange, etc.)
          findingsData.findings.forEach((finding, index) => {
            addConsolidatedResultToUI(finding, index);
          });
          addLogEntry('result', `Restored ${findingsData.findings.length} findings from previous session`);
        }
      } catch (e) {
        console.warn('Could not restore findings:', e);
      }

      // Use resumeScreening() which connects to existing session without resetting
      resumeScreening();
    }

    // Disconnect active screening (keeps session in Redis)
    let currentEventSource = null;  // Track the active EventSource
    let currentHealthCheckInterval = null;  // Track health check interval for cleanup
    async function disconnectScreening() {
      // Clear health check interval to prevent auto-reconnect
      if (currentHealthCheckInterval) {
        clearInterval(currentHealthCheckInterval);
        currentHealthCheckInterval = null;
      }
      if (currentEventSource) {
        currentEventSource.close();
        currentEventSource = null;
      }

      // CRITICAL: Tell server to PAUSE processing
      if (sessionId) {
        try {
          await fetch(`/api/session/${sessionId}/pause`, { method: 'POST' });
          console.log('[PAUSE] Sent pause request to server');
        } catch (e) {
          console.error('[PAUSE] Failed to pause server:', e);
        }
      }

      document.getElementById('disconnectBtn').style.display = 'none';
      document.getElementById('resumeBtn').style.display = 'inline-block';
      document.getElementById('searchBtn').disabled = false;
      addLogEntry('warn', 'Paused. Session preserved - click Resume to continue.');
      updateActivityStats('Paused');
    }

    // Resume from disconnect (reconnect to same session)
    async function resumeScreening() {
      const savedSessionId = localStorage.getItem('ddowl_sessionId');
      const savedName = localStorage.getItem('ddowl_sessionName');

      if (!savedSessionId || !savedName) {
        addLogEntry('error', 'No session to resume');
        return;
      }

      // Restore queue item context if resuming a queue-initiated screening
      const savedQueueItemId = localStorage.getItem('ddowl_queueItemId');
      if (savedQueueItemId && !currentQueueItemId) {
        currentQueueItemId = savedQueueItemId;
        console.log('[RESUME] Restored queue item ID:', savedQueueItemId);
      }

      // Clear pause flag on server FIRST
      try {
        await fetch(`/api/session/${savedSessionId}/resume`, { method: 'POST' });
        console.log('[RESUME] Cleared pause flag on server');
      } catch (e) {
        console.error('[RESUME] Failed to clear pause flag:', e);
      }

      // Set state for resume
      sessionId = savedSessionId;
      document.getElementById('nameInput').value = savedName;
      document.getElementById('resumeBtn').style.display = 'none';
      document.getElementById('disconnectBtn').style.display = 'inline-block';

      addLogEntry('search', `Resuming screening for: ${savedName}`);
      updateActivityStats('Resuming...');

      // Start SSE connection with existing sessionId
      const variations = [savedName];
      const language = selectedLanguage;

      // Retry state
      let retryCount = 0;
      const MAX_RETRIES = 3;
      let eventSource = null;
      let lastMessageTime = Date.now();

      function connectSSE() {
        const variationsParam = variations.length > 1 ? `&variations=${encodeURIComponent(variations.join(','))}` : '';
        const languageParam = `&language=${language}`;
        const url = `/api/screen/v4?name=${encodeURIComponent(savedName)}${variationsParam}${languageParam}&sessionId=${savedSessionId}`;
        console.log(`[SSE RESUME] Connecting: ${url}`);
        eventSource = new EventSource(url);
        currentEventSource = eventSource;

        // Initialize multi-tab sync and become leader
        ScreeningSync.init(savedSessionId);
        ScreeningSync.becomeLeader();
        ScreeningSync.broadcastState('running');

        // Health check
        if (currentHealthCheckInterval) {
          clearInterval(currentHealthCheckInterval);
        }
        lastMessageTime = Date.now();
        currentHealthCheckInterval = setInterval(() => {
          const gap = Date.now() - lastMessageTime;
          if (gap > 60000) {
            console.warn(`[SSE] No heartbeat for ${gap}ms, reconnecting...`);
            addLogEntry('warn', `Connection stale, reconnecting...`);
            eventSource.close();
            clearInterval(currentHealthCheckInterval);
            currentHealthCheckInterval = null;
            if (retryCount < MAX_RETRIES) {
              retryCount++;
              setTimeout(connectSSE, 1000);
            }
          }
        }, 5000);

        // Handle SSE messages for resume
        eventSource.onmessage = (event) => {
          lastMessageTime = Date.now();
          retryCount = 0;
          const data = JSON.parse(event.data);

          // Skip heartbeat
          if (data.type === 'heartbeat') return;

          // Handle reconnection status
          if (data.type === 'reconnect_status') {
            addLogEntry('result', `✓ Reconnected. ${data.message}`);
            updateActivityStats(`Reconnected: ${data.phaseName} phase${data.progress ? ` (${data.progress})` : ''}`);
          }

          // Handle phase events
          if (data.type === 'phase') {
            addLogEntry('search', `━━━ PHASE ${data.phase}: ${data.name} ━━━`);
            addLogEntry('search', data.message);
            updateActivityStats(`Phase ${data.phase}: ${data.name}`);
            // Update progress bar to phase start percentage
            const phaseName = data.name?.toLowerCase() || '';
            const phaseKey = phaseName.includes('gather') ? 'gather' :
                            phaseName.includes('eliminat') ? 'eliminate' :
                            phaseName.includes('cluster') ? 'cluster' :
                            phaseName.includes('categor') ? 'categorize' :
                            phaseName.includes('analyz') ? 'analyze' :
                            phaseName.includes('consolid') ? 'consolidate' : null;
            if (phaseKey && PHASE_WEIGHTS[phaseKey]) {
              updateProgressCard('running', PHASE_WEIGHTS[phaseKey].start, progressState.redCount, progressState.amberCount, savedName);
            }
          }

          if (data.type === 'phase_skipped') {
            addLogEntry('search', `Phase ${data.phase} skipped: ${data.reason}`);
          }

          // Handle search progress
          if (data.type === 'search_page') {
            const stopReason = data.pageResults === 0 ? ' → STOP (empty)' : (data.pageResults < 10 ? ' → STOP (last page)' : '');
            addLogEntry('search', `  Q${data.queryIndex} Page ${data.page}: ${data.pageResults} results${stopReason}`);
          }

          if (data.type === 'search_progress') {
            addLogEntry('search', `Query ${data.queryIndex}/${data.totalQueries} | ${data.resultsFound} results | ${data.query}`);
            updateActivityStats(`Searching ${data.queryIndex}/${data.totalQueries} (${data.totalSoFar} total)`);
          }

          // Handle clustering
          if (data.type === 'cluster_batch_start') {
            addLogEntry('analyze', `  [Batch ${data.batch}/${data.totalBatches}] Clustering ${data.articlesInBatch} articles...`);
            updateActivityStats(`Clustering batch ${data.batch}/${data.totalBatches}`);
          }

          if (data.type === 'cluster_batch_complete') {
            const labels = data.clusterLabels?.slice(0, 5).join(', ') || '';
            addLogEntry('analyze', `  [Batch ${data.batch}/${data.totalBatches}] Found ${data.clustersFound} incidents: ${labels}`);
            // Update progress bar for clustering
            const pct = calculateOverallProgress('cluster', data.batch, data.totalBatches);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, savedName);
          }

          // Handle phase_resumed - restore cumulative counts from batches processed before disconnect
          if (data.type === 'phase_resumed') {
            if (data.partialResults) {
              progressState.redCount = data.partialResults.red || 0;
              progressState.amberCount = data.partialResults.amber || 0;
              // Update progress card display immediately with restored counts
              updateProgressCard('running', progressState.percentage || 0, progressState.redCount, progressState.amberCount, savedName);
              addLogEntry('result', `Restored counts: ${progressState.redCount} RED, ${progressState.amberCount} AMBER from previous batches`);
            }
            addLogEntry('info', data.message || `Resuming ${data.phase} phase`);
          }

          // Handle categorization
          if (data.type === 'categorize_batch_complete') {
            addLogEntry('analyze', `Batch ${data.batch}/${data.totalBatches}: ${data.processedSoFar}/${data.totalItems} (${data.batchRed} RED, ${data.batchAmber} AMBER)`);
            updateActivityStats(`Categorizing ${data.processedSoFar}/${data.totalItems}...`);
            // Update progress bar for categorization with cumulative counts
            const pct = calculateOverallProgress('categorize', data.batch, data.totalBatches);
            // Add batch counts to running total
            progressState.redCount = (progressState.redCount || 0) + (data.batchRed || 0);
            progressState.amberCount = (progressState.amberCount || 0) + (data.batchAmber || 0);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, savedName);
          }

          // Handle analyze
          if (data.type === 'analyze_start') {
            addLogEntry('fetch', `[${data.index}/${data.total}] Analyzing: ${data.title}`, data.url);
            // Update progress bar for analyze phase
            const pct = calculateOverallProgress('analyze', data.index, data.total);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, savedName);
          }

          if (data.type === 'analyze_skip') {
            addLogEntry('analyze', `[${data.index}/${data.total}] Skipped: ${data.reason} | ${data.title}`, data.url);
            // Update progress bar even for skipped items
            const pct = calculateOverallProgress('analyze', data.index, data.total);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, savedName);
          }

          if (data.type === 'analyze_result') {
            if (data.isAdverse) {
              const color = data.severity === 'RED' ? 'red' : 'amber';
              addLogEntry(color, `${data.severity}: ${data.headline}`, data.url);
              addResultToUI({
                url: data.url,
                title: data.title,
                severity: data.severity,
                summary: data.headline + ' - ' + data.summary
              });
              // Update progress bar with new finding counts
              const newRed = progressState.redCount + (data.severity === 'RED' ? 1 : 0);
              const newAmber = progressState.amberCount + (data.severity === 'AMBER' ? 1 : 0);
              updateProgressCard('running', progressState.percentage, newRed, newAmber, savedName);
            } else {
              addLogEntry('green', `Clear`, data.url);
            }
          }

          // Handle paused event (server stopped due to pause flag)
          if (data.type === 'paused') {
            addLogEntry('warn', `Server paused at ${data.phase} phase`);
            updateActivityStats('Paused by server');
          }

          // Handle completion
          if (data.type === 'complete') {
            if (currentHealthCheckInterval) {
              clearInterval(currentHealthCheckInterval);
              currentHealthCheckInterval = null;
            }
            eventSource.close();
            const stats = data.stats || {};

            addLogEntry('result', `━━━ SCREENING COMPLETE ━━━`);
            addLogEntry('result', `Total searched: ${stats.totalSearchResults || 0}`);
            addLogEntry('result', `Findings: ${stats.red || 0} RED, ${stats.amber || 0} AMBER`);

            currentSubjectName = savedName;
            currentFindings = data.findings || [];

            if (data.findings && data.findings.length > 0) {
              document.getElementById('redFlagsList').innerHTML = '';
              document.getElementById('amberFlagsList').innerHTML = '';
              redCount = 0;
              amberCount = 0;
              for (let i = 0; i < data.findings.length; i++) {
                addConsolidatedResultToUI(data.findings[i], i);
              }
              selectedFindings.clear();
              updateSelectedCount();
              document.getElementById('generateReportBtn').disabled = false;
            }

            document.getElementById('statusDot').classList.remove('active');
            document.getElementById('searchBtn').disabled = false;
            document.getElementById('disconnectBtn').style.display = 'none';
            document.getElementById('resumeBtn').style.display = 'none';
            currentEventSource = null;
            updateActivityStats(`Done: ${stats.red || 0} red, ${stats.amber || 0} amber`);

            // Update progress bar to complete state
            updateProgressCard('complete', 100, stats.red || 0, stats.amber || 0, savedName);

            // Clear session on complete
            localStorage.removeItem('ddowl_sessionId');
            localStorage.removeItem('ddowl_sessionName');
            sessionId = null;

            // Update queue item if this was a queue-initiated screening
            if (currentQueueItemId) {
              const greenCount = (stats.totalSearchResults || 0) - (stats.red || 0) - (stats.amber || 0);
              QueueManager.update(currentQueueItemId, {
                status: 'complete',
                completedAt: Date.now(),
                stats: { red: stats.red || 0, amber: stats.amber || 0, green: greenCount },
                findings: currentFindings,
                subjectName: currentSubjectName
              });
              currentQueueItemId = null;
              localStorage.removeItem('ddowl_queueItemId');
              renderQueue();

              // Auto-run next in queue after short delay
              setTimeout(() => {
                const nextItem = QueueManager.getNext();
                if (nextItem) {
                  addLogEntry('info', `[Queue] Auto-continuing to: ${nextItem.subjectName}`);
                  runNextInQueue();
                } else {
                  addLogEntry('info', '[Queue] All subjects completed!');
                }
              }, 2000);
            }
          }

          if (data.type === 'error') {
            addLogEntry('error', `[ERROR] ${data.message}`);
            eventSource.close();
            resetUI();

            // Mark queue item as error
            if (currentQueueItemId) {
              QueueManager.update(currentQueueItemId, { status: 'error' });
              currentQueueItemId = null;
              localStorage.removeItem('ddowl_queueItemId');
              renderQueue();
            }
          }

          // Broadcast to follower tabs
          ScreeningSync.broadcast(data);
        };

        eventSource.onerror = () => {
          eventSource.close();
          if (currentHealthCheckInterval) {
            clearInterval(currentHealthCheckInterval);
            currentHealthCheckInterval = null;
          }
          if (retryCount < MAX_RETRIES) {
            retryCount++;
            addLogEntry('warn', `Connection lost. Reconnecting (${retryCount}/${MAX_RETRIES})...`);
            setTimeout(connectSSE, 2000 * retryCount);
          } else {
            addLogEntry('error', 'Max retries exceeded. Please try again.');
            resetUI();

            // Mark queue item as error on max retries
            if (currentQueueItemId) {
              QueueManager.update(currentQueueItemId, { status: 'error' });
              currentQueueItemId = null;
              localStorage.removeItem('ddowl_queueItemId');
              renderQueue();
            }
          }
        };
      }

      connectSSE();
    }

    function getTimestamp() {
      const now = new Date();
      return now.toTimeString().slice(0, 8);
    }

    function addLogEntry(type, message, url = null, snippet = null) {
      const log = document.getElementById('activityLog');
      const entry = document.createElement('div');
      entry.className = 'log-entry';

      let messageHtml = message;
      if (url) {
        // Show URL as visible clickable text after the message
        messageHtml = `${message} | <a href="${url}" target="_blank" style="color: #666;">${url}</a>`;
      }
      if (snippet) {
        messageHtml += ` | <span style="color: #555;">${snippet}</span>`;
      }

      entry.innerHTML = `
        <span class="log-time">${getTimestamp()}</span>
        <span class="log-type ${type}">${type.toUpperCase()}</span>
        <span class="log-message">${messageHtml}</span>
      `;

      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
      logEntries++;
    }

    function updateActivityStats(text) {
      document.getElementById('activityStats').textContent = text;
    }

    function toggleActivityPanel() {
      const panel = document.getElementById('activityPanel');
      const btn = document.getElementById('togglePanel');
      panel.classList.toggle('active');
      btn.textContent = panel.classList.contains('active') ? 'Hide Log' : 'Show Log';
    }

    // Activity panel resize functionality
    (function initActivityResize() {
      const panel = document.getElementById('activityPanel');
      const handle = document.getElementById('activityResizeHandle');
      let isResizing = false;
      let startY = 0;
      let startHeight = 0;

      handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = panel.offsetHeight;
        panel.style.transition = 'none'; // Disable transition during drag
        document.body.style.cursor = 'ns-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = startY - e.clientY;
        const newHeight = Math.min(Math.max(startHeight + deltaY, 150), window.innerHeight - 100);
        panel.style.height = newHeight + 'px';
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          panel.style.transition = ''; // Re-enable transition
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          // Save height preference
          localStorage.setItem('ddowl_activityHeight', panel.style.height);
        }
      });

      // Restore saved height
      const savedHeight = localStorage.getItem('ddowl_activityHeight');
      if (savedHeight) {
        panel.style.height = savedHeight;
      }

      // Touch support for mobile
      handle.addEventListener('touchstart', (e) => {
        isResizing = true;
        startY = e.touches[0].clientY;
        startHeight = panel.offsetHeight;
        panel.style.transition = 'none';
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        const deltaY = startY - e.touches[0].clientY;
        const newHeight = Math.min(Math.max(startHeight + deltaY, 150), window.innerHeight - 100);
        panel.style.height = newHeight + 'px';
      }, { passive: true });

      document.addEventListener('touchend', () => {
        if (isResizing) {
          isResizing = false;
          panel.style.transition = '';
          localStorage.setItem('ddowl_activityHeight', panel.style.height);
        }
      });
    })();

    function copyActivityLog() {
      const logDiv = document.getElementById('activityLog');
      const logText = logDiv.innerText;
      navigator.clipboard.writeText(logText).then(() => {
        const btn = document.querySelector('.copy-log-btn');
        btn.classList.add('copied');
        setTimeout(() => btn.classList.remove('copied'), 1500);
      }).catch(err => {
        console.error('Failed to copy log:', err);
      });
    }

    // Name variation management
    function addVariation() {
      const container = document.getElementById('variationsContainer');
      const row = document.createElement('div');
      row.className = 'variation-row';
      row.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px;';
      row.innerHTML = `
        <input type="text" class="variation-input" placeholder="e.g., 陈大文" style="flex: 1;">
        <button type="button" onclick="removeVariation(this)" style="padding: 10px 14px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; color: #666; cursor: pointer; font-size: 16px;" title="Remove">×</button>
      `;
      container.appendChild(row);
      row.querySelector('input').focus();
    }

    function removeVariation(btn) {
      const container = document.getElementById('variationsContainer');
      const rows = container.querySelectorAll('.variation-row');
      if (rows.length > 1) {
        btn.parentElement.remove();
      } else {
        // Don't remove last row, just clear it
        btn.parentElement.querySelector('input').value = '';
      }
    }

    function getVariations() {
      const inputs = document.querySelectorAll('.variation-input');
      const variations = [];
      inputs.forEach(input => {
        const val = input.value.trim();
        if (val && !variations.includes(val)) {
          variations.push(val);
        }
      });
      return variations;
    }

    function addToQueue() {
      const name = document.getElementById('nameInput').value.trim();
      const variations = getVariations();
      const language = selectedLanguage;

      if (name.length < 2) {
        alert('Please enter a valid name (2+ characters)');
        return;
      }

      QueueManager.add({
        name: name,
        variants: variations,
        language: language
      });

      // Clear input
      document.getElementById('nameInput').value = '';
      // Clear all variation inputs
      document.querySelectorAll('.variation-input').forEach(input => {
        input.value = '';
      });

      // Re-render queue
      renderQueue();
    }

    // Start a NEW screening - always fresh, always clears old session
    function startScreening() {
      const name = document.getElementById('nameInput').value.trim();
      const additionalVariations = getVariations();
      const language = selectedLanguage;

      if (name.length < 2) {
        alert('Please enter a valid name (2+ characters)');
        return;
      }

      // Always include main name first, then additional variations
      const variations = [name];
      additionalVariations.forEach(v => {
        if (v !== name && !variations.includes(v)) {
          variations.push(v);
        }
      });

      // ALWAYS start fresh - clear any old session
      sessionId = null;
      localStorage.removeItem('ddowl_sessionId');
      localStorage.removeItem('ddowl_sessionName');

      // Reset all UI state
      redCount = 0;
      amberCount = 0;
      greenCount = 0;
      logEntries = 0;
      urlsProcessed = 0;
      currentReport = null;
      currentFindings = [];
      currentSubjectName = '';
      furtherLinks = [];

      // Clear UI elements
      document.getElementById('furtherLinksBtn').style.display = 'none';
      document.getElementById('furtherLinksCount').textContent = '0';
      document.getElementById('redFlagsList').innerHTML = '';
      document.getElementById('amberFlagsList').innerHTML = '';
      document.getElementById('redCount').textContent = '0';
      document.getElementById('amberCount').textContent = '0';
      document.getElementById('activityLog').innerHTML = '';
      document.getElementById('generateReportBtn').disabled = true;

      // Show progress card in running state
      updateProgressCard('running', 0, 0, 0, name);

      // Hide legacy UI elements
      document.getElementById('disconnectBtn').style.display = 'none';
      document.getElementById('resumeBtn').style.display = 'none';

      // Show activity panel
      document.getElementById('activityPanel').classList.add('active');
      document.getElementById('statusDot').classList.add('active');
      document.getElementById('togglePanel').classList.remove('hidden');
      document.getElementById('searchBtn').disabled = true;

      addLogEntry('search', `Starting screening for: ${name}`);
      updateActivityStats('Initializing...');

      // Retry state
      let retryCount = 0;
      const MAX_RETRIES = 3;
      let lastQueryIndex = 0;
      let eventSource = null;
      let lastMessageTime = Date.now();

      function connectSSE() {
        // Build reconnection URL - use sessionId (stored in Redis on server)
        // This replaces the old approach of encoding huge state in URL params
        const sessionParam = sessionId ? `&sessionId=${sessionId}` : '';
        const variationsParam = variations.length > 1 ? `&variations=${encodeURIComponent(variations.join(','))}` : '';
        const languageParam = `&language=${language}`;
        const url = `/api/screen/v4?name=${encodeURIComponent(name)}${variationsParam}${languageParam}${sessionParam}`;
        console.log(`[SSE] Connecting: ${url}`);
        eventSource = new EventSource(url);
        currentEventSource = eventSource;  // Track globally for disconnect button

        // Health check: detect stale connections before they die
        // Clear any existing health check first
        if (currentHealthCheckInterval) {
          clearInterval(currentHealthCheckInterval);
        }
        lastMessageTime = Date.now();
        currentHealthCheckInterval = setInterval(() => {
          const gap = Date.now() - lastMessageTime;
          if (gap > 60000) { // 60 seconds without any message (allow time for Gemini categorization)
            console.warn(`[SSE] No heartbeat for ${gap}ms, proactively reconnecting...`);
            addLogEntry('warn', `Connection stale (${Math.round(gap/1000)}s), reconnecting...`);
            eventSource.close();
            clearInterval(currentHealthCheckInterval);
            currentHealthCheckInterval = null;
            if (retryCount < MAX_RETRIES) {
              retryCount++;
              setTimeout(connectSSE, 1000);
            }
          }
        }, 5000);

        eventSource.onmessage = (event) => {
          lastMessageTime = Date.now(); // Update on ANY message (including heartbeat)
          retryCount = 0; // Reset retry count on successful message
          const data = JSON.parse(event.data);

          // Store session ID for reconnection (stored in Redis on server)
          if (data.type === 'session') {
            sessionId = data.sessionId;
            localStorage.setItem('ddowl_sessionId', sessionId);
            localStorage.setItem('ddowl_sessionName', name);
            console.log(`[SSE] Received session ID: ${sessionId}`);

            // Save to session history for Recent Searches panel
            SessionHistory.save({
              sessionId: sessionId,
              subjectName: name,
              language: selectedLanguage,
              startTime: Date.now(),
              status: 'in_progress',
              phase: 'gather'
            });

            // Update URL for bookmarking/sharing
            Router.setSessionUrl(sessionId);

            // Save sessionId to queue item for persistence across browser close
            if (currentQueueItemId) {
              QueueManager.update(currentQueueItemId, { sessionId: data.sessionId });
            }

            // Initialize multi-tab sync and become leader
            ScreeningSync.init(sessionId);
            ScreeningSync.becomeLeader();
            ScreeningSync.screeningState = 'running';
          }

          // Handle reconnection status - show clear context about where we are
          if (data.type === 'reconnect_status') {
            addLogEntry('result', `\u2713 Reconnected. ${data.message}`);
            updateActivityStats(`Reconnected: ${data.phaseName} phase${data.progress ? ` (${data.progress})` : ''}`);
            if (data.findingsCount > 0) {
              addLogEntry('result', `  ${data.findingsCount} findings restored from previous session`);
            }
          }

          // Handle phase skipped (reconnection)
          if (data.type === 'phase_skipped') {
            addLogEntry('search', `Phase ${data.phase} skipped: ${data.reason}`);
          }

          // Handle analyze resume (reconnection)
          if (data.type === 'analyze_resume') {
            addLogEntry('search', `Resuming analysis from article ${data.fromIndex + 1}, ${data.totalFindings} findings restored`);
          }

          // Track query progress for potential retry
          if (data.queryIndex) lastQueryIndex = data.queryIndex;

          // === V4 PHASE EVENTS ===
          if (data.type === 'phase') {
            addLogEntry('search', `━━━ PHASE ${data.phase}: ${data.name} ━━━`);
            addLogEntry('search', data.message);
            updateActivityStats(`Phase ${data.phase}: ${data.name}`);
            // Update session history with current phase
            if (sessionId) {
              SessionHistory.update(sessionId, { phase: data.name.toLowerCase() });
            }
            // Update progress bar to phase start
            const phaseName = data.name?.toLowerCase() || '';
            const phaseKey = phaseName.includes('gather') ? 'gather' :
                            phaseName.includes('eliminat') ? 'eliminate' :
                            phaseName.includes('cluster') ? 'cluster' :
                            phaseName.includes('categor') ? 'categorize' :
                            phaseName.includes('analyz') ? 'analyze' :
                            phaseName.includes('consolid') ? 'consolidate' : null;
            if (phaseKey && PHASE_WEIGHTS[phaseKey]) {
              updateProgressCard('running', PHASE_WEIGHTS[phaseKey].start, progressState.redCount, progressState.amberCount, name);
            }
          }

          // === CLUSTERING EVENTS ===
          if (data.type === 'cluster_batch_start') {
            addLogEntry('analyze', `  [Batch ${data.batch}/${data.totalBatches}] Clustering ${data.articlesInBatch} articles...`);
            updateActivityStats(`Clustering batch ${data.batch}/${data.totalBatches}`);
          }

          if (data.type === 'cluster_batch_complete') {
            const labels = data.clusterLabels?.slice(0, 5).join(', ') || '';
            const more = data.clusterLabels?.length > 5 ? ` (+${data.clusterLabels.length - 5} more)` : '';
            addLogEntry('analyze', `  [Batch ${data.batch}/${data.totalBatches}] Found ${data.clustersFound} incidents: ${labels}${more}`);
            // Update progress bar
            const pct = calculateOverallProgress('cluster', data.batch, data.totalBatches);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
          }

          if (data.type === 'cluster_merge_complete') {
            addLogEntry('result', `Merged to ${data.totalClusters} unique incidents`);
            // Log first 10 incident labels
            if (data.clusterLabels && data.clusterLabels.length > 0) {
              const toShow = data.clusterLabels.slice(0, 10);
              toShow.forEach((label, i) => {
                addLogEntry('analyze', `  ${i + 1}. ${label}`);
              });
              if (data.clusterLabels.length > 10) {
                addLogEntry('analyze', `  ... and ${data.clusterLabels.length - 10} more incidents`);
              }
            }
          }

          if (data.type === 'incident_clusters') {
            addLogEntry('result', `━━━ CLUSTERING RESULT ━━━`);
            addLogEntry('result', `${data.totalArticles} articles → ${data.totalClusters} incidents`);
            addLogEntry('result', `Keeping ${data.articlesToAnalyze} for analysis, parking ${data.articlesParked} duplicates`);
            addLogEntry('analyze', `Duration: ${(data.duration/1000).toFixed(1)}s`);
          }

          if (data.type === 'search_page') {
            // Per-page logging for pagination debugging
            const stopReason = data.pageResults === 0 ? ' → STOP (empty)' : (data.pageResults < 10 ? ' → STOP (last page)' : '');
            addLogEntry('search', `  Q${data.queryIndex} Page ${data.page}: ${data.pageResults} results${stopReason}`);
          }

          if (data.type === 'search_progress') {
            addLogEntry('search', `Query ${data.queryIndex}/${data.totalQueries} | ${data.resultsFound} results | ${data.query}`);
            updateActivityStats(`Searching ${data.queryIndex}/${data.totalQueries} (${data.totalSoFar} total)`);
            // Update progress bar
            const pct = calculateOverallProgress('gather', data.queryIndex, data.totalQueries);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
          }

          if (data.type === 'gather_complete') {
            addLogEntry('result', `Gathered ${data.totalResults} URLs in ${(data.duration/1000).toFixed(1)}s`);
            // Note: Results now stored in Redis on server, no client-side tracking needed
          }

          // Per-result logging - clickable full URL with snippet
          if (data.type === 'search_result') {
            addLogEntry('search', `[${data.index}/${data.total}] ${data.title}`, data.url, data.snippet);
          }

          if (data.type === 'programmatic_elimination_complete') {
            addLogEntry('analyze', `Programmatic filter: ${data.before} → ${data.after} (${data.eliminated} eliminated)`);
            if (data.govBypassed > 0) {
              addLogEntry('analyze', `  (.gov.cn bypassed: ${data.govBypassed})`);
            }
          }

          // Phase 1.75: LLM Title Deduplication
          if (data.type === 'title_dedupe_progress') {
            addLogEntry('fetch', `Title dedupe batch ${data.batchNumber}/${data.totalBatches}: ${data.processedSoFar}/${data.totalItems} (${data.duplicatesFound} duplicates found)`);
          }

          if (data.type === 'title_dedupe_complete') {
            addLogEntry('analyze', `Title dedupe: ${data.before} → ${data.after} (${data.duplicatesRemoved} duplicates removed, ${data.groupsFound} groups)`);
          }

          // Per-item elimination logging - clickable full URL
          if (data.type === 'elimination_item') {
            if (data.status === 'PASSED') {
              addLogEntry('analyze', `[${data.index}] PASS | ${data.title}`, data.url);
            } else if (data.status === 'BYPASSED') {
              addLogEntry('fetch', `[${data.index}] BYPASS | ${data.title} | ${data.rule}`, data.url);
            } else if (data.status === 'ELIMINATED') {
              addLogEntry('search', `[${data.index}] ELIM | ${data.title} | ${data.rule}`, data.url);
            }
          }

          // Handle phase_resumed - restore cumulative counts from batches processed before disconnect
          if (data.type === 'phase_resumed') {
            if (data.partialResults) {
              progressState.redCount = data.partialResults.red || 0;
              progressState.amberCount = data.partialResults.amber || 0;
              // Update progress card display immediately with restored counts
              updateProgressCard('running', progressState.percentage || 0, progressState.redCount, progressState.amberCount, name);
              addLogEntry('result', `Restored counts: ${progressState.redCount} RED, ${progressState.amberCount} AMBER from previous batches`);
            }
            addLogEntry('info', data.message || `Resuming ${data.phase} phase`);
          }

          if (data.type === 'categorize_batch_complete') {
            addLogEntry('analyze', `Batch ${data.batch}/${data.totalBatches}: ${data.processedSoFar}/${data.totalItems} (${data.batchRed} RED, ${data.batchAmber} AMBER)`);
            updateActivityStats(`Categorizing ${data.processedSoFar}/${data.totalItems}...`);
            // Update progress bar with cumulative counts
            const pct = calculateOverallProgress('categorize', data.batch, data.totalBatches);
            // Add batch counts to running total
            progressState.redCount = (progressState.redCount || 0) + (data.batchRed || 0);
            progressState.amberCount = (progressState.amberCount || 0) + (data.batchAmber || 0);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
          }

          if (data.type === 'categorize_complete') {
            addLogEntry('result', `Categorized: ${data.red} RED, ${data.amber} AMBER, ${data.green} GREEN`);
          }

          if (data.type === 'dedupe') {
            const totalRemoved = data.redRemoved + data.amberRemoved;
            addLogEntry('result', `Deduped: removed ${totalRemoved} duplicates (${data.redRemoved} red, ${data.amberRemoved} amber). Analyzing ${data.redCount} red + ${data.amberCount} amber unique.`);
          }

          // Title similarity grouping - same story on multiple sites
          if (data.type === 'title_grouped') {
            const totalParked = data.redParked + data.amberParked;
            if (totalParked > 0) {
              addLogEntry('result', `Title grouping: parked ${totalParked} similar stories (${data.redParked} red, ${data.amberParked} amber). Analyzing ${data.redAnalyze} red + ${data.amberAnalyze} amber.`);
            }
          }

          // Categorized item - colored severity, title, URL, snippet
          if (data.type === 'categorized_item') {
            if (data.category === 'RED') {
              addLogEntry('red', `${data.title}`, data.url, data.snippet);
            } else if (data.category === 'AMBER') {
              addLogEntry('amber', `${data.title}`, data.url, data.snippet);
            } else if (data.category === 'GREEN') {
              addLogEntry('green', `${data.title}`, data.url, data.snippet);
            }
          }

          if (data.type === 'eliminate_complete') {
            addLogEntry('result', `Consolidated: ${data.before} → ${data.after} findings`);
          }

          // === STAGE 0: SEARCH (V3 compatibility) ===
          if (data.type === 'query_start') {
            addLogEntry('search', `━━━ QUERY ${data.queryIndex}/${data.totalQueries} ━━━`);
            addLogEntry('search', `${data.query}`);
            updateActivityStats(`Query ${data.queryIndex}/${data.totalQueries}`);
          }

          // Removed duplicate search_page handler - V4 uses search_progress instead

          if (data.type === 'search_results') {
            addLogEntry('search', `→ Total: ${data.found} results`);
          }

          if (data.type === 'duplicates_skipped') {
            addLogEntry('analyze', `  ↳ Skipped ${data.count} duplicate URLs (already processed)`);
          }

          // Handle query errors (continue processing)
          if (data.type === 'query_error') {
            addLogEntry('error', `Query ${data.queryIndex} failed: ${data.error}`);
          }

          // Handle skipped queries (from reconnect)
          if (data.type === 'query_skipped') {
            addLogEntry('search', `↷ Query ${data.queryIndex} skipped (${data.reason})`);
          }

          // === STAGE 1: PRE-SCREENING ===
          if (data.type === 'triage_start') {
            addLogEntry('fetch', `Pre-screening ${data.count} results...`);
          }

          if (data.type === 'triage_item') {
            const title = data.title;
            if (data.classification === 'GREEN') {
              addLogEntry('analyze', `✓ Cleared: ${title}`);
            } else if (data.classification === 'YELLOW') {
              addLogEntry('fetch', `⚡ Review: ${title}`);
            } else {
              addLogEntry('red', `⚠ Flagged: ${title}`);
            }
          }

          if (data.type === 'triage_summary') {
            addLogEntry('search', `Pre-screen: ${data.green} cleared, ${data.toInvestigate} for review`);
          }

          // === STAGE 2: QUICK SCAN ===
          if (data.type === 'quick_scan_start') {
            const title = data.title;
            addLogEntry('fetch', `Quick scanning: ${title}`);
            urlsProcessed++;
          }

          if (data.type === 'quick_scan_result') {
            if (data.shouldAnalyze) {
              addLogEntry('amber', `→ Needs deep analysis: ${data.reason}`);
            } else {
              addLogEntry('analyze', `→ Cleared: ${data.reason}`);
            }
          }

          // === STAGE 3: DEEP ANALYSIS ===
          if (data.type === 'analyze_start') {
            addLogEntry('fetch', `[${data.index}/${data.total}] Analyzing: ${data.title}`, data.url);
            // Update progress bar
            const pct = calculateOverallProgress('analyze', data.index, data.total);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
          }

          if (data.type === 'analyze_skip') {
            addLogEntry('analyze', `[${data.index}/${data.total}] Skipped: ${data.reason} | ${data.title}`, data.url);
            // Update progress bar even for skipped items
            const pct = calculateOverallProgress('analyze', data.index, data.total);
            updateProgressCard('running', pct, progressState.redCount, progressState.amberCount, name);
          }

          if (data.type === 'analyze_result') {
            // Note: Findings now stored in Redis on server, no client-side tracking needed
            if (data.action === 'SKIP') {
              addLogEntry('analyze', `Cleared: ${data.reason}`, data.url);
            } else if (data.isAdverse) {
              const color = data.severity === 'RED' ? 'red' : 'amber';
              addLogEntry(color, `${data.severity}: ${data.headline}`, data.url);
              addResultToUI({
                url: data.url,
                title: data.title,
                severity: data.severity,
                summary: data.headline + ' - ' + data.summary
              });
              // Update progress bar with new finding counts
              const newRed = progressState.redCount + (data.severity === 'RED' ? 1 : 0);
              const newAmber = progressState.amberCount + (data.severity === 'AMBER' ? 1 : 0);
              updateProgressCard('running', progressState.percentage, newRed, newAmber, name);
            } else {
              addLogEntry('green', `Clear`, data.url);
            }
          }

          if (data.type === 'analyze_error') {
            addLogEntry('error', `  → ERROR: ${data.error}`);
          }

          // Further links - RED/AMBER articles that LLM couldn't verify (403, paywall, etc.)
          // Also includes parked duplicates from clustering (isParked=true)
          // Collect silently during analyze, show summary at end
          if (data.type === 'further_link') {
            furtherLinks.push({
              url: data.url,
              title: data.title,
              reason: data.reason || 'Content mismatch',
              originalCategory: data.originalCategory,
              triageReason: data.triageReason,
              isParked: data.isParked || false,  // Parked duplicates vs verification failures
            });
            // Only count non-parked items (verification failures need manual review)
            const reviewCount = furtherLinks.filter(l => !l.isParked).length;
            document.getElementById('furtherLinksCount').textContent = reviewCount;
            // Don't log each one - we'll show a summary at the end
          }

          // === CONSOLIDATION ===
          if (data.type === 'consolidating') {
            addLogEntry('fetch', `Consolidating ${data.count} findings...`);
            updateActivityStats('Consolidating...');
          }

          if (data.type === 'consolidated') {
            if (data.before !== data.after) {
              addLogEntry('result', `Consolidated: ${data.before} findings → ${data.after} unique incidents`);
            }
          }

          // === COMPLETION ===
          if (data.type === 'complete') {
            if (currentHealthCheckInterval) {
              clearInterval(currentHealthCheckInterval);
              currentHealthCheckInterval = null;
            }
            eventSource.close();
            const stats = data.stats || {};

            // Update session history to completed
            if (sessionId) {
              SessionHistory.update(sessionId, {
                status: 'complete',
                phase: 'complete',
                findingsCount: data.findings?.length || 0
              });
            }
            addLogEntry('result', `━━━ SCREENING COMPLETE ━━━`);
            addLogEntry('result', `Total searched: ${stats.totalSearchResults || 0}`);
            addLogEntry('result', `Total cleared: ${stats.totalCleared || 0}`);
            addLogEntry('result', `Findings: ${stats.red || 0} RED, ${stats.amber || 0} AMBER`);

            // Update progress bar to 100%
            updateProgressCard('complete', 100, stats.red || 0, stats.amber || 0, name);

            // Update clear count (green counter removed from UI)
            greenCount = stats.totalCleared || 0;

            // Store findings for report generation
            currentSubjectName = name;
            currentFindings = data.findings || [];

            // Display consolidated findings
            if (data.findings && data.findings.length > 0) {
              // Clear existing results first
              document.getElementById('redFlagsList').innerHTML = '';
              document.getElementById('amberFlagsList').innerHTML = '';
              redCount = 0;
              amberCount = 0;
              document.getElementById('redCount').textContent = '0';
              document.getElementById('amberCount').textContent = '0';

              // Add consolidated findings to UI with index for selection
              for (let i = 0; i < data.findings.length; i++) {
                addConsolidatedResultToUI(data.findings[i], i);
              }
              // Reset selections
              selectedFindings.clear();
              updateSelectedCount();

              // Enable Generate Report button
              document.getElementById('generateReportBtn').disabled = false;

              saveToScreeningLog(name, {
                flags: {
                  red: data.findings.filter(f => f.severity === 'RED'),
                  amber: data.findings.filter(f => f.severity === 'AMBER')
                },
                totalResultsAnalyzed: stats.totalAnalyzed
              });
            } else {
              // No findings - disable report generation
              document.getElementById('generateReportBtn').disabled = true;
            }

            document.getElementById('statusDot').classList.remove('active');
            document.getElementById('searchBtn').disabled = false;
            document.getElementById('disconnectBtn').style.display = 'none';
            document.getElementById('resumeBtn').style.display = 'none';
            currentEventSource = null;
            updateActivityStats(`Done: ${stats.red || 0} red, ${stats.amber || 0} amber`);

            // Show Further Links summary if there are any
            const reviewNeeded = furtherLinks.filter(l => !l.isParked);
            const parkedCount = furtherLinks.filter(l => l.isParked).length;

            if (furtherLinks.length > 0) {
              document.getElementById('furtherLinksBtn').style.display = 'block';
              document.getElementById('furtherLinksCount').textContent = reviewNeeded.length;

              // Only log verification failures as AMBER (not parked duplicates)
              if (reviewNeeded.length > 0) {
                addLogEntry('result', `━━━ MANUAL REVIEW NEEDED (${reviewNeeded.length}) ━━━`);
                for (const link of reviewNeeded) {
                  const categoryTag = link.originalCategory ? `[${link.originalCategory}]` : '';
                  addLogEntry('amber', `${categoryTag} ${link.reason}`, link.url, link.title);
                }
              }

              // Parked duplicates logged as info (not amber)
              if (parkedCount > 0) {
                addLogEntry('info', `${parkedCount} duplicate articles parked (covered by higher-tier sources)`);
              }
            }

            // Clear session from localStorage on successful completion
            localStorage.removeItem('ddowl_sessionId');
            localStorage.removeItem('ddowl_sessionName');
            sessionId = null;

            eventSource.close();

            // After successful completion, update queue and run next
            if (currentQueueItemId) {
              QueueManager.update(currentQueueItemId, {
                status: 'complete',
                completedAt: Date.now(),
                stats: { red: stats.red || 0, amber: stats.amber || 0, green: greenCount },
                findings: currentFindings,
                subjectName: currentSubjectName
              });
              currentQueueItemId = null;
              localStorage.removeItem('ddowl_queueItemId');
              renderQueue();

              // Auto-run next in queue after short delay
              setTimeout(() => {
                const nextItem = QueueManager.getNext();
                if (nextItem) {
                  addLogEntry('info', `[Queue] Auto-continuing to: ${nextItem.subjectName}`);
                  runNextInQueue();
                } else {
                  addLogEntry('info', '[Queue] All subjects completed!');
                }
              }, 2000);
            }
          }

          if (data.type === 'error') {
            addLogEntry('error', `[ERROR] ${data.message}`);
            eventSource.close();
            resetUI();

            // Mark queue item as error
            if (currentQueueItemId) {
              QueueManager.update(currentQueueItemId, { status: 'error' });
              currentQueueItemId = null;
              localStorage.removeItem('ddowl_queueItemId');
              renderQueue();
            }
          }

          // Broadcast to follower tabs
          ScreeningSync.broadcast(data);
        };

        eventSource.onerror = () => {
          eventSource.close();
          if (currentHealthCheckInterval) {
            clearInterval(currentHealthCheckInterval);
            currentHealthCheckInterval = null;
          }
          if (retryCount < MAX_RETRIES) {
            retryCount++;
            addLogEntry('warn', `Connection lost. Reconnecting (${retryCount}/${MAX_RETRIES})...`);
            setTimeout(connectSSE, 2000 * retryCount);
          } else {
            addLogEntry('error', 'Max retries exceeded. Please try again.');
            resetUI();

            // Mark queue item as error on max retries
            if (currentQueueItemId) {
              QueueManager.update(currentQueueItemId, { status: 'error' });
              currentQueueItemId = null;
              localStorage.removeItem('ddowl_queueItemId');
              renderQueue();
            }
          }
        };
      }

      // Start the connection
      connectSSE();
    }

    function addResultToUI(result) {
      const listId = result.severity === 'RED' ? 'redFlagsList' : 'amberFlagsList';
      const list = document.getElementById(listId);

      if (result.severity === 'RED') {
        redCount++;
        document.getElementById('redCount').textContent = redCount;
      } else {
        amberCount++;
        document.getElementById('amberCount').textContent = amberCount;
      }

      const item = document.createElement('div');
      item.className = `flag-item ${result.severity.toLowerCase()}`;
      item.innerHTML = `
        <div class="flag-title">
          <a href="${result.url}" target="_blank">${escapeHtml(result.title)}</a>
        </div>
        <div class="flag-summary">${escapeHtml(result.summary)}</div>
        <div class="flag-meta">
          <span class="flag-category">${escapeHtml(result.category)}</span>
          <span>${new URL(result.url).hostname}</span>
        </div>
      `;
      list.appendChild(item);

      document.getElementById('resultsSection').classList.add('active');
    }

    // Track selected findings for detailed report
    let selectedFindings = new Set();

    function updateSelectedCount() {
      const count = selectedFindings.size;
      document.getElementById('selectedCount').textContent = count;
      document.getElementById('generateReportBtn').disabled = count === 0;
      document.getElementById('furtherSearchBtn').disabled = count === 0;
    }

    function toggleFindingSelection(checkbox, findingIndex) {
      const item = checkbox.closest('.flag-item');
      if (checkbox.checked) {
        selectedFindings.add(findingIndex);
        item.classList.add('selected');
      } else {
        selectedFindings.delete(findingIndex);
        item.classList.remove('selected');
      }
      updateSelectedCount();
    }

    // Add consolidated finding to UI (with source count badge and checkbox)
    function addConsolidatedResultToUI(finding, index) {
      const listId = finding.severity === 'RED' ? 'redFlagsList' : 'amberFlagsList';
      const list = document.getElementById(listId);

      if (finding.severity === 'RED') {
        redCount++;
        document.getElementById('redCount').textContent = redCount;
      } else {
        amberCount++;
        document.getElementById('amberCount').textContent = amberCount;
      }

      // Build sources list
      const sources = finding.sources || [];
      const sourcesHtml = sources.length > 1
        ? `<div class="flag-sources">
            <span class="source-badge">${sources.length} sources</span>
            <div class="sources-list">
              ${sources.map(s => `<a href="${s.url}" target="_blank">${escapeHtml(s.title || new URL(s.url).hostname)}</a>`).join('')}
            </div>
          </div>`
        : sources.length === 1
          ? `<div class="flag-sources"><a href="${sources[0].url}" target="_blank">${new URL(sources[0].url).hostname}</a></div>`
          : '';

      const dateRangeHtml = finding.dateRange
        ? `<span class="flag-date">${escapeHtml(finding.dateRange)}</span>`
        : '';

      const item = document.createElement('div');
      item.className = `flag-item ${finding.severity.toLowerCase()}`;
      item.dataset.findingIndex = index;
      item.innerHTML = `
        <input type="checkbox" class="finding-checkbox" onchange="toggleFindingSelection(this, ${index})">
        <div class="flag-content">
          <div class="flag-header">
            <div class="flag-title">${escapeHtml(finding.headline)}</div>
            ${dateRangeHtml}
          </div>
          <div class="flag-summary">${escapeHtml(finding.summary)}</div>
          ${sourcesHtml}
        </div>
      `;
      list.appendChild(item);

      document.getElementById('resultsSection').classList.add('active');
    }

    function showFinalResults(report) {
      document.getElementById('resultsSection').classList.add('active');
      document.getElementById('searchBtn').disabled = false;

      const actionText = document.getElementById('actionText');
      actionText.textContent = report.recommendedAction;

      if (report.recommendedAction.includes('ESCALATE')) {
        actionText.className = 'action-text escalate';
      } else if (report.recommendedAction.includes('REVIEW')) {
        actionText.className = 'action-text review';
      } else {
        actionText.className = 'action-text clear';
      }
    }

    function resetUI() {
      document.getElementById('searchBtn').disabled = false;
      document.getElementById('statusDot').classList.remove('active');
      document.getElementById('disconnectBtn').style.display = 'none';
      document.getElementById('resumeBtn').style.display = 'none';
      currentEventSource = null;
    }

    function downloadReport() {
      if (!currentReport) return;

      const blob = new Blob([JSON.stringify(currentReport, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `ddowl-${currentReport.subject}-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Further Links Modal
    function openFurtherLinksModal() {
      const modal = document.getElementById('furtherLinksModal');
      const list = document.getElementById('furtherLinksList');

      // Populate list with enhanced info
      list.innerHTML = furtherLinks.map(link => {
        const categoryBadge = link.originalCategory
          ? `<span class="further-link-category ${link.originalCategory.toLowerCase()}">${link.originalCategory}</span>`
          : '';
        const reasonText = link.reason ? `<div class="further-link-reason">${escapeHtml(link.reason)}</div>` : '';
        const triageText = link.triageReason ? `<div class="further-link-triage">${escapeHtml(link.triageReason)}</div>` : '';

        return `
          <div class="further-link-item">
            <div class="further-link-header">
              ${categoryBadge}
              <a href="${escapeHtml(link.url)}" target="_blank" class="further-link-title">${escapeHtml(link.title)}</a>
            </div>
            ${reasonText}
            ${triageText}
            <div class="further-link-url">${escapeHtml(link.url)}</div>
          </div>
        `;
      }).join('');

      modal.style.display = 'flex';
    }

    function closeFurtherLinksModal() {
      document.getElementById('furtherLinksModal').style.display = 'none';
    }

    // Close modal on backdrop click
    document.getElementById('furtherLinksModal')?.addEventListener('click', (e) => {
      if (e.target.classList.contains('further-links-modal')) {
        closeFurtherLinksModal();
      }
    });

    async function saveToScreeningLog(subjectName, report) {
      try {
        const response = await fetch('/api/screening-log/ddowl-run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            subject_name: subjectName,
            red_flags: report.flags.red.map(f => ({
              title: f.title,
              url: f.url,
              summary: f.summary,
              category: f.category
            })),
            amber_flags: report.flags.amber.map(f => ({
              title: f.title,
              url: f.url,
              summary: f.summary,
              category: f.category
            })),
            sources_checked: report.totalResultsAnalyzed
          })
        });
        if (response.ok) {
          addLogEntry('result', 'Results saved to screening log');
        }
      } catch (err) {
        console.log('Could not save to screening log:', err);
      }
    }

    document.getElementById('nameInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') startScreening();
    });

    // ============================================================
    // REPORT GENERATION
    // ============================================================

    let currentFindings = [];
    let currentSubjectName = '';
    let reportContent = '';
    let reportGenerating = false;

    function openReportModal() {
      if (currentFindings.length === 0) {
        alert('No findings to generate report from');
        return;
      }

      const modal = document.getElementById('reportModal');
      const content = document.getElementById('reportContent');
      const status = document.getElementById('reportModalStatus');
      const title = document.getElementById('reportModalTitle');

      // Reset modal state
      content.innerHTML = '<span class="report-cursor"></span>';
      reportContent = '';
      reportGenerating = true;

      title.textContent = `Generating Report for ${currentSubjectName}`;
      status.classList.remove('complete');
      status.querySelector('span').textContent = 'Writing...';

      document.getElementById('copyReportBtn').disabled = true;
      document.getElementById('downloadWordBtn').disabled = true;

      modal.classList.add('active');

      // Start streaming report generation
      generateReport();
    }

    function closeReportModal() {
      document.getElementById('reportModal').classList.remove('active');
      reportGenerating = false;
    }

    async function generateReport() {
      const content = document.getElementById('reportContent');
      const status = document.getElementById('reportModalStatus');

      try {
        const response = await fetch('/api/report/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            subjectName: currentSubjectName,
            findings: currentFindings
          })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });

          // Process SSE messages
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));

                if (data.type === 'chunk') {
                  reportContent += data.content;
                  renderReport();
                }

                if (data.type === 'complete') {
                  reportGenerating = false;
                  status.classList.add('complete');
                  status.querySelector('span').textContent = 'Complete';
                  document.getElementById('copyReportBtn').disabled = false;
                  document.getElementById('downloadWordBtn').disabled = false;
                  // Remove cursor
                  const cursor = content.querySelector('.report-cursor');
                  if (cursor) cursor.remove();
                }

                if (data.type === 'error') {
                  reportGenerating = false;
                  status.querySelector('span').textContent = 'Error: ' + data.message;
                  const cursor = content.querySelector('.report-cursor');
                  if (cursor) cursor.remove();
                }
              } catch (e) {
                // Ignore parse errors
              }
            }
          }
        }
      } catch (error) {
        console.error('Report generation error:', error);
        status.querySelector('span').textContent = 'Error: ' + error.message;
        reportGenerating = false;
      }
    }

    function renderReport() {
      const content = document.getElementById('reportContent');
      // Simple markdown rendering
      let html = reportContent
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/_(.+?)_/g, '<em>$1</em>')
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');

      content.innerHTML = html + (reportGenerating ? '<span class="report-cursor"></span>' : '');
      content.scrollTop = content.scrollHeight;
    }

    function copyReport() {
      navigator.clipboard.writeText(reportContent).then(() => {
        const btn = document.getElementById('copyReportBtn');
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = originalText, 2000);
      });
    }

    // ============================================================
    // DETAILED REPORT GENERATION
    // ============================================================

    let detailReportContent = '';

    function closeDetailReportModal() {
      document.getElementById('detailReportModal').classList.remove('active');
    }

    function copyDetailReport() {
      navigator.clipboard.writeText(detailReportContent).then(() => {
        const btn = document.getElementById('copyDetailReportBtn');
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = originalText, 2000);
      });
    }

    async function generateDetailedReport() {
      if (selectedFindings.size === 0) {
        alert('Please select at least one finding');
        return;
      }

      // Get selected findings
      const selected = Array.from(selectedFindings).map(i => currentFindings[i]).filter(Boolean);
      if (selected.length === 0) return;

      // Open modal
      const modal = document.getElementById('detailReportModal');
      const content = document.getElementById('detailReportContent');
      const status = document.getElementById('detailReportStatus');

      content.innerHTML = '<div style="color: #666; text-align: center; padding: 40px;">Generating professional due diligence report...</div>';
      detailReportContent = '';
      status.classList.remove('complete');
      status.querySelector('span').textContent = `Generating report for ${selected.length} finding(s)...`;
      document.getElementById('copyDetailReportBtn').disabled = true;

      modal.classList.add('active');

      try {
        // Use new batch report generation endpoint
        const response = await fetch(`/api/session/${sessionId || 'default'}/generate-report`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            findings: selected,
            subjectName: currentSubjectName,
          })
        });

        const data = await response.json();

        if (data.success && data.sections) {
          let reportHtml = '';
          let reportText = '';

          for (const section of data.sections) {
            // HTML for display (with formatting)
            reportHtml += `
              <div class="detail-finding">
                <div class="detail-finding-header">${escapeHtml(section.headline)}</div>
                <div class="detail-finding-section">
                  <p style="line-height: 1.8; text-align: justify;">${escapeHtml(section.paragraph)}</p>
                </div>
                <div class="detail-finding-section">
                  <h4>Sources</h4>
                  <p style="font-size: 12px; color: #888;">${section.sources?.map(url => `<a href="${escapeHtml(url)}" target="_blank" style="color: #4a9eff;">${escapeHtml(url)}</a>`).join('<br>') || 'N/A'}</p>
                </div>
              </div>
            `;

            // Plain text for clipboard
            reportText += `## ${section.headline}\n\n${section.paragraph}\n\nSources:\n${section.sources?.map(url => '- ' + url).join('\n') || 'N/A'}\n\n---\n\n`;
          }

          content.innerHTML = reportHtml;
          detailReportContent = reportText;
          status.classList.add('complete');
          status.querySelector('span').textContent = 'Complete';
          document.getElementById('copyDetailReportBtn').disabled = false;
        } else {
          content.innerHTML = `
            <div class="detail-finding">
              <div class="detail-finding-header">Error</div>
              <div class="detail-finding-section">
                <p style="color: #ff4757;">${escapeHtml(data.error || 'Failed to generate report')}</p>
              </div>
            </div>
          `;
        }
      } catch (err) {
        content.innerHTML = `
          <div class="detail-finding">
            <div class="detail-finding-header">Error</div>
            <div class="detail-finding-section">
              <p style="color: #ff4757;">Error: ${escapeHtml(err.message)}</p>
            </div>
          </div>
        `;
        status.querySelector('span').textContent = 'Failed';
      }
    }

    async function furtherSearchSelected() {
      if (selectedFindings.size === 0) {
        alert('Please select at least one finding');
        return;
      }

      // Get selected findings
      const selected = Array.from(selectedFindings).map(i => currentFindings[i]).filter(Boolean);
      if (selected.length === 0) return;

      // Build search queries from findings
      const queries = selected.map(f => {
        // Extract key terms from headline for targeted search
        return `"${currentSubjectName}" ${f.headline.replace(/Name match:?\s*/i, '').slice(0, 50)}`;
      });

      // Open modal to show progress
      const modal = document.getElementById('detailReportModal');
      const content = document.getElementById('detailReportContent');
      const status = document.getElementById('detailReportStatus');

      content.innerHTML = '<div style="color: #666; text-align: center; padding: 40px;">Searching for more information...</div>';
      status.classList.remove('complete');
      status.querySelector('span').textContent = `Searching...`;
      document.getElementById('copyDetailReportBtn').disabled = true;

      modal.classList.add('active');

      try {
        const response = await fetch('/api/findings/expand', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            findings: selected,
            subjectName: currentSubjectName,
          })
        });

        const data = await response.json();

        if (data.success) {
          let html = '<h2 style="color: #fff; margin-bottom: 20px;">Additional Search Results</h2>';

          for (const result of data.results) {
            html += `
              <div class="detail-finding">
                <div class="detail-finding-header">${escapeHtml(result.query)}</div>
                <div class="detail-finding-section">
                  ${result.items.map(item => `
                    <div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #222;">
                      <a href="${escapeHtml(item.url)}" target="_blank" style="color: #4a9eff; font-weight: 600;">${escapeHtml(item.title)}</a>
                      <p style="color: #888; font-size: 12px; margin-top: 4px;">${escapeHtml(item.snippet || '')}</p>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
          }

          content.innerHTML = html;
          status.classList.add('complete');
          status.querySelector('span').textContent = `Found ${data.results.reduce((sum, r) => sum + r.items.length, 0)} results`;
        } else {
          content.innerHTML = `<div style="color: #ff4757; text-align: center; padding: 40px;">Search failed: ${escapeHtml(data.error)}</div>`;
          status.querySelector('span').textContent = 'Failed';
        }
      } catch (err) {
        content.innerHTML = `<div style="color: #ff4757; text-align: center; padding: 40px;">Error: ${escapeHtml(err.message)}</div>`;
        status.querySelector('span').textContent = 'Error';
      }
    }

    async function downloadWord() {
      const btn = document.getElementById('downloadWordBtn');
      btn.disabled = true;
      btn.textContent = 'Generating...';

      try {
        // Use docx library via CDN
        const { Document, Paragraph, TextRun, HeadingLevel, Packer } = docx;

        // Parse report content into document structure
        const lines = reportContent.split('\n');
        const children = [];

        for (const line of lines) {
          if (line.startsWith('# ')) {
            children.push(new Paragraph({
              text: line.slice(2),
              heading: HeadingLevel.HEADING_1
            }));
          } else if (line.startsWith('## ')) {
            children.push(new Paragraph({
              text: line.slice(3),
              heading: HeadingLevel.HEADING_2
            }));
          } else if (line.startsWith('**') && line.endsWith('**')) {
            children.push(new Paragraph({
              children: [new TextRun({ text: line.slice(2, -2), bold: true })]
            }));
          } else if (line.trim()) {
            // Handle inline formatting
            const runs = [];
            let remaining = line;

            // Simple bold handling
            const boldRegex = /\*\*(.+?)\*\*/g;
            let lastIndex = 0;
            let match;

            while ((match = boldRegex.exec(line)) !== null) {
              if (match.index > lastIndex) {
                runs.push(new TextRun(line.slice(lastIndex, match.index)));
              }
              runs.push(new TextRun({ text: match[1], bold: true }));
              lastIndex = match.index + match[0].length;
            }

            if (lastIndex < line.length) {
              runs.push(new TextRun(line.slice(lastIndex)));
            }

            if (runs.length > 0) {
              children.push(new Paragraph({ children: runs }));
            } else {
              children.push(new Paragraph({ text: line }));
            }
          } else {
            children.push(new Paragraph({ text: '' }));
          }
        }

        const doc = new Document({
          sections: [{
            properties: {},
            children: children
          }]
        });

        const blob = await Packer.toBlob(doc);
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `DD-Report-${currentSubjectName}-${Date.now()}.docx`;
        a.click();
        URL.revokeObjectURL(url);

        btn.textContent = 'Download Word';
        btn.disabled = false;
      } catch (error) {
        console.error('Word generation error:', error);
        alert('Failed to generate Word document: ' + error.message);
        btn.textContent = 'Download Word';
        btn.disabled = false;
      }
    }
  </script>
  <!-- docx library for Word export -->
  <script src="https://unpkg.com/docx@8.5.0/build/index.umd.min.js"></script>
</body>
</html>
